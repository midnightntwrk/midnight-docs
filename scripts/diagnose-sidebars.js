#!/usr/bin/env node
/**
 * Diagnose Docusaurus sidebar issues:
 * - Finds duplicate doc IDs referenced in sidebars
 * - Flags IDs that don't have a matching file (docs/<id>.mdx|md)
 *
 * Usage:
 *   node scripts/diagnose-sidebars.js --sidebars sidebars.js --docsDir docs
 *
 * Notes:
 * - Only checks explicitly referenced docs:
 *     - strings inside `items: []`
 *     - { type: 'doc', id: '...' }
 *   It *skips* { type: 'autogenerated' } and { type: 'link' }.
 */

const fs = require('fs');
const path = require('path');

function getArg(name, fallback) {
  const i = process.argv.indexOf(`--${name}`);
  return i >= 0 ? process.argv[i + 1] : fallback;
}

const sidebarsPath = path.resolve(process.cwd(), getArg('sidebars', 'sidebars.js'));
const docsDir = path.resolve(process.cwd(), getArg('docsDir', 'docs'));

if (!fs.existsSync(sidebarsPath)) {
  console.error(`❌ Sidebars file not found: ${sidebarsPath}`);
  process.exit(1);
}
if (!fs.existsSync(docsDir)) {
  console.error(`❌ Docs dir not found: ${docsDir}`);
  process.exit(1);
}

// Load sidebars (CommonJS or ESM default)
let sidebarsMod = require(sidebarsPath);
const sidebars = sidebarsMod.default || sidebarsMod.sidebar || sidebarsMod;

if (!sidebars) {
  console.error('❌ Could not load sidebar object (expected export of object with key "sidebar" or default).');
  process.exit(1);
}

const explicitDocIds = [];

/** Recursively walk sidebar items and collect explicit doc IDs */
function walk(node) {
  if (!node) return;

  // string = doc id (Docusaurus treats as doc by default)
  if (typeof node === 'string') {
    explicitDocIds.push(node);
    return;
  }

  if (Array.isArray(node)) {
    node.forEach(walk);
    return;
  }

  if (typeof node === 'object') {
    const t = node.type;

    // category
    if (t === 'category' && node.items) {
      walk(node.items);
      return;
    }

    // explicit doc
    if (t === 'doc' && node.id) {
      explicitDocIds.push(node.id);
      return;
    }

    // links & autogenerated are ignored (no explicit doc ID)
    if (t === 'link' || t === 'autogenerated') return;

    // if object has nested items anyway
    if (node.items) walk(node.items);
  }
}

// sidebars can be: { sidebar: [...] } or just an array, or an object keyed by sidebar names
if (Array.isArray(sidebars)) {
  walk(sidebars);
} else if (typeof sidebars === 'object') {
  for (const key of Object.keys(sidebars)) {
    walk(sidebars[key]);
  }
}

function findDocPathForId(id) {
  // Try <id>.mdx, <id>.md
  const tryPaths = [
    path.join(docsDir, `${id}.mdx`),
    path.join(docsDir, `${id}.md`),

    // Common patterns people use for "README" vs "index"
    // If id ends with '/README' also check '/index'
    id.endsWith('/README') ? path.join(docsDir, id.replace(/\/README$/, '/index.mdx')) : null,
    id.endsWith('/README') ? path.join(docsDir, id.replace(/\/README$/, '/index.md')) : null,
    // If id ends with '/index' also check '/README'
    id.endsWith('/index') ? path.join(docsDir, id.replace(/\/index$/, '/README.mdx')) : null,
    id.endsWith('/index') ? path.join(docsDir, id.replace(/\/index$/, '/README.md')) : null,
  ].filter(Boolean);

  for (const p of tryPaths) {
    if (fs.existsSync(p)) return p;
  }
  return null;
}

// Count duplicates
const counts = explicitDocIds.reduce((acc, id) => {
  acc[id] = (acc[id] || 0) + 1;
  return acc;
}, {});

const duplicates = Object.entries(counts)
  .filter(([, n]) => n > 1)
  .map(([id, n]) => ({ id, count: n }));

// Resolve paths and missing
const results = explicitDocIds.map((id) => {
  const resolved = findDocPathForId(id);
  return { id, file: resolved, status: resolved ? 'OK' : 'MISSING' };
});

// Pretty print
function unique(arr) {
  return Array.from(new Set(arr));
}

console.log('────────────────────────────────────────────────────────');
console.log('Docusaurus Sidebar Diagnostic\n');

console.log('Checked sidebars:', sidebarsPath);
console.log('Docs directory  :', docsDir, '\n');

if (duplicates.length) {
  console.log('⚠️  Duplicate doc IDs (referenced more than once):');
  for (const { id, count } of duplicates) {
    console.log(`  - ${id}  (x${count})`);
  }
  console.log('');
} else {
  console.log('✅ No duplicate doc IDs found.\n');
}

const missing = results.filter(r => r.status === 'MISSING');
const ok = results.filter(r => r.status === 'OK');

console.log(`Referenced doc IDs: ${unique(explicitDocIds).length}`);
console.log(`Found files       : ${ok.length}`);
console.log(`Missing files     : ${missing.length}\n`);

if (missing.length) {
  console.log('❌ Missing (no matching file found):');
  for (const r of unique(missing.map(m => m.id))) {
    console.log(`  - ${r}`);
  }
  console.log('');
}

// Optional: list mapped OK items (useful for sanity checks)
if (ok.length) {
  console.log('✅ Resolved IDs → files (sample up to 20):');
  ok.slice(0, 20).forEach(({ id, file }) => console.log(`  - ${id}  →  ${path.relative(process.cwd(), file)}`));
  if (ok.length > 20) console.log(`  ...and ${ok.length - 20} more\n`);
}

console.log('Done.');
console.log('────────────────────────────────────────────────────────');
