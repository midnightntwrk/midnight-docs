---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
id: module-6
title: Building Decentralized Applications (DApps) on Midnight
displayed_sidebar: academySidebar
---

import QuizWithRetry from '@site/src/components/QuizWithRetry';
import AuthGuard from '@site/src/components/AuthGuard';
import LoggedInUserInfo from '@site/src/components/LoggedInUserInfo';
import LogoutButton from '@site/src/components/LogoutButton';

# Module 6: Building Decentralized Applications (DApps) on Midnight

## Introduction

This module walks learners through creating, testing, and deploying a full-stack decentralized application (DApp) on the Midnight blockchain using the Compact framework. It includes hands-on development, front-end integration, and deployment on TestNet-02. Multiple-choice quizzes are provided at the end of each major section to reinforce learning outcomes.

## Learning Objectives

By the end of this module, you will be able to:

- Understand the core components and privacy model of Midnight’s blockchain and smart contract platform.
- Set up a local development environment tailored for building on Midnight, including Docker, Node.js, and the Lace wallet.
- Write, compile, and test smart contracts using the Compact domain-specific language.
- Build a full-stack DApp that interfaces with a Midnight smart contract using TypeScript and Midnight.js.
- Connect a frontend securely to the Midnight network via indexers, proof servers, and the Lace wallet DApp connector.
- Test your DApp in a local standalone environment and on the public TestNet-02 network.
- Use automated testing libraries to ensure functional correctness and privacy guarantees of your application.
- Deploy a complete privacy-preserving DApp and verify contract interaction and state changes on Midnight.

## What is a DApp on Midnight?

Unlike conventional DApps that publish all interactions on-chain, Midnight ensures user data stays private by default. Developers can selectively disclose information when needed, but private state is never stored publicly.

Developing DApps on Midnight involves a streamlined yet privacy-centric workflow designed for building secure, zero-knowledge-based decentralized applications. Unlike conventional blockchain development, Midnight emphasizes confidentiality and selective data disclosure as first-class design principles.

Key aspects include:

* **Setting Up the Development Environment**: Developers install Docker, Node.js, and the Compact compiler. The Lace Wallet (a Chrome extension) is used for managing identities and signing transactions. A local proof server is run to handle zero-knowledge proof generation. Test tokens (tDUST) are acquired from the testnet faucet to cover transaction fees.

* **Writing Smart Contracts in Compact**: Midnight smart contracts are written in Compact, a privacy-enforcing domain-specific language inspired by TypeScript. Compact allows you to define which variables are private and which can be publicly disclosed. The Compact compiler generates both cryptographic artifacts and strongly typed TypeScript/JavaScript APIs.

* **Building the DApp Frontend/Backend**: DApps on Midnight are typically developed in TypeScript or JavaScript, using the generated contract APIs. The Midnight.js SDK offers utilities for blockchain interaction, wallet integration, and managing private state transitions.

* **Testing in a Local Environment**: Midnight supports full-stack local development using Docker. Developers can simulate the entire stack (node, indexer, proof server) offline to validate contract behavior and data privacy before deploying to the public testnet.

* **Deploying and Interacting on TestNet-02**: After successful testing, DApps can be deployed to Midnight TestNet-02, allowing interaction with real network services in a sandboxed environment. This stage supports user testing, transaction signing, and remote proof generation.

* **Using Developer Tools**: Midnight provides a CLI wallet, a VSCode extension for Compact, a mock node for simulations, and built-in testing libraries for automation. The ecosystem is designed to support iterative development and high-confidence deployment.

In short, building DApps on Midnight means combining secure, privacy-first smart contracts with a robust developer experience tailored for scalable, confidential applications.

<AuthGuard>
  <>
    <LoggedInUserInfo />
    <LogoutButton />

    <QuizWithRetry
      questions={[
        {
          question: 'What is the role of the Compact language in Midnight DApp development?',
          options: [
            'It defines transaction fees for privacy settings',
            'It allows you to program user wallets',
            'It enforces data privacy rules and generates typed APIs for contracts',
            'It optimizes gas usage across different blockchains',
          ],
          answer: 2,
        },
        {
          question: 'Which component handles zero-knowledge proof generation in the local development environment?',
          options: [
            'Docker Compose',
            'Lace Wallet',
            'Midnight CLI',
            'Proof Server',
          ],
          answer: 3,
        },
        {
          question: 'What does the Lace Wallet extension allow you to do?',
          options: [
            'Deploy contracts directly from GitHub',
            'Sign transactions and manage DApp identities',
            'Run a private Midnight node on your browser',
            'Query GraphQL endpoints directly',
          ],
          answer: 1,
        },
        {
          question: 'What are the main outputs of the Compact compiler?',
          options: [
            'WebAssembly modules and Solidity wrappers',
            'Encrypted source code and execution traces',
            'TypeScript APIs and cryptographic artifacts',
            'Node.js scripts and custom frontends',
          ],
          answer: 2,
        },
        {
          question: 'Which of the following best describes the Midnight testnet?',
          options: [
            'A mainnet fork used for public token trading',
            'An offline simulator with no smart contract support',
            'A public sandbox network for testing and iteration',
            'A mock server for backend database testing',
          ],
          answer: 2,
        },
      ]}
    />
  </>
</AuthGuard>

## Environment Setup and First Contract

This section walks you through the foundational steps for developing decentralized applications (DApps) on the Midnight blockchain. Midnight is built around privacy and zero-knowledge proofs, and its development workflow reflects that with specialized tools and architecture.

You’ll begin by installing and configuring the necessary environment—this includes Docker, Node.js, the Compact compiler, and the Lace Wallet extension. Then, you’ll create a project scaffold, write your first Compact smart contract, and compile it into a usable form. 

### Setting Up Your Environment

To begin building on Midnight, install the essential tools and configure your development environment:

- **Docker Desktop** – Required to run local instances like the proof server.
- **Google Chrome (v119 or later)** – Required for installing the Lace wallet extension.
- **Node.js (v18 LTS)** – Runtime for JavaScript tooling and DApp development:

  ```bash
  nvm install 18 --lts
  ```
- **Lace Wallet Chrome Extension**:
  - Install from the [here](https://chromewebstore.google.com/detail/lace-beta/hgeekaiplokcnmakghbdfbgnlfheichg).


### Configure Wallet and Get Test Tokens

1. Create a new wallet address in Lace.

2. Request tDUST from the [Midnight testnet faucet](https://midnight.network/test-faucet/).

3. Run the proof server:

   ```bash
   docker run -p 6300:6300 midnightnetwork/proof-server -- midnight-proof-server --network testnet
   ```


### Install the Compact Compiler

1. Install the Compact developer tools:

   ```bash
   curl --proto '=https' --tlsv1.2 -LsSf https://github.com/midnightntwrk/compact/releases/latest/download/compact-installer.sh | sh
   ```

2. Update to the latest toolchain and test installation:

   ```bash
   compact update
   compact compile --version
   ```

3. No environment variable needed:

   The new developer tools eliminate the need for `COMPACT_HOME`. The `compact` command automatically manages compiler locations.

:::note
For more information about the Compact developer tools, see the [release announcement](https://docs.midnight.network/dev-diaries/introducing-compact-developer-tools).
:::


## Install the VSCode Compact Extension

1. Download the `.vsix` file from the [Midnight releases page](https://docs.midnight.network/relnotes/vs-code-extension).
2. In VSCode, go to **Extensions → ... → Install from VSIX...** and select the file.

## Create Project Structure

Instead of manually creating folders and files, we will use the `create-mn-app` tool to scaffold a "Student" project. This generates a complete DApp structure with a working CLI and test harness, but with the smart contract code removed—filling it in is your challenge!

1.  Run the following command in your terminal:

    ```bash
    npx create-mn-app@latest my-counter-dapp --template student
    ```

    You will be prompted to select an example project. Choose **Counter**.

2.  Navigate into your new project directory:

    ```bash
    cd my-counter-dapp
    ```

The generated project structure looks like this:

```
my-counter-dapp/
├── contract/         # Smart contract development workspace
│   ├── src/
│   │   ├── counter.compact  # <--- THIS IS EMPTY/INCOMPLETE. Your job is to fix it!
│   │   └── test/            # Pre-written tests to verify your work
│   └── package.json         # Scripts for compiling and testing
├── dapp-cli/         # Working CLI that interacts with the contract
└── README.md
```

*   **`contract/`**: This is where you will work. It contains the `counter.compact` file you need to write and tests to check your progress.
*   **`dapp-cli/`**: A fully implemented CLI tool that's ready to go. Once you've successfully implemented the contract, this tool will just work!

### The Challenge: Implement the Contract

Your task is to implement the **Counter** smart contract in `contract/src/counter.compact`.

1.  Open `contract/src/counter.compact` in VSCode.
2.  Write the contract code to define a ledger state for the counter and an operation to increment it.

Here is the robust solution you should aim for (try to write it yourself first!):

```javascript
pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

// public state
export ledger round: Counter;

// transition function changing public state
export circuit increment(): [] {
  round.increment(1);
}
```

**What's happening here?**

*   `pragma language_version ...`: Specifies the supported compiler versions.
*   `import CompactStandardLibrary;`: Imports standard types like `Counter`.
*   `export ledger round: Counter;`: Declares a public state variable named `round` of type `Counter`. This is stored on the Midnight ledger.
*   `export circuit increment(): [] { ... }`: Defines a public circuit (transaction) that increments the `round` counter by 1.

3.  Compile your contract to check for syntax errors:

    ```bash
    cd contract
    npm run compact
    ```

    If this command succeeds, the compiler has generated the necessary artifacts (including the TypeScript API) in `src/managed/`.

### Understanding the `managed/` Directory

When you run `npm run compact`, the compiler generates several files in the `contract/src/managed/` directory. Understanding these artifacts is key to understanding how Midnight works under the hood.

*   **`contract/`**: This directory contains the TypeScript interface and runtime bindings for your smart contract.
    *   `index.d.cts`: Type definitions that expose your `Contract` class, `Circuits`, and `Ledger` state. Your frontend uses this to ensure it calls your contract correctly.
    *   `index.cjs`: The compiled JavaScript runtime for the contract.

*   **`keys/`**: Contains the cryptographic keys generated for your circuits.
    *   `increment.prover`: The **Proving Key**. This is used by the **Proof Server** to generate zero-knowledge proofs that attest to the validity of your transaction without revealing private data.
    *   `increment.verifier`: The **Verifying Key**. This is used by the Midnight Network (validators) to verify the proof submitted by your DApp.

*   **`zkir/`**: Contains the **Zero-Knowledge Intermediate Representation (ZKIR)**.
    *   `increment.zkir` / `increment.bzkir`: These files represent the logic of your contract's circuits in a format that the ZK proof system understands. The proof server uses these along with the proving key.

*   **`compiler/`**: Contains metadata about the compilation process.
    *   `contract-info.json`: JSON file describing the contract's structure, including lists of circuits (`increment`), witnesses, and return types.

<AuthGuard>
  <>
    <LoggedInUserInfo />
    <LogoutButton />

    <QuizWithRetry
      questions={[
        {
          question: 'Why is Docker required in the Midnight development environment?',
          options: [
            'To compile smart contracts into WebAssembly',
            'To run the local proof server and testnet services',
            'To install Lace Wallet in the browser',
            'To deploy contracts to mainnet',
          ],
          answer: 1,
        },
        {
          question: 'What is the purpose of the Lace Wallet Chrome extension?',
          options: [
            'To deploy Docker containers',
            'To query on-chain events from a testnet node',
            'To sign transactions and manage wallet identities',
            'To compile and execute Compact smart contracts',
          ],
          answer: 2,
        },
        {
          question: 'What does the command `nvm install 18 --lts` do?',
          options: [
            'Installs the Compact compiler globally',
            'Starts a local testnet node',
            'Installs the Long-Term Support version of Node.js',
            'Installs the Midnight CLI tools',
          ],
          answer: 2,
        },
        {
          question: 'What is required to run the local proof server?',
          options: [
            'A Lace wallet with testnet tokens',
            'Docker and the correct proof-server image',
            'The VSCode Compact extension',
            'A running GraphQL indexer',
          ],
          answer: 1,
        },
        {
          question: 'What is the purpose of the `compact --skip-zk` command?',
          options: [
            'To skip compiling contract logic',
            'To compile the contract without generating zero-knowledge proofs',
            'To only build frontend APIs',
            'To skip runtime verification checks',
          ],
          answer: 1,
        }
      ]}
    />
  </>
</AuthGuard>

## Front-End Integration: A Deep Dive

The `create-mn-app` scaffold includes a `dapp-cli` directory containing a fully functional command-line interface (CLI) for your DApp. Even though you didn't write this code, understanding how it connects to your smart contract is crucial.

The CLI acts as the bridge between the user (terminal) and the Midnight network (smart contract). It handles:
1.  **Wallet Connection**: Accessing credentials to sign transactions.
2.  **Provider Configuration**: Setting up connections to the node, indexer, and proof server.
3.  **Contract Interaction**: Calling the methods you defined in `counter.compact`.

### 1. The Interaction Loop (`cli.ts`)

The entry point of the application is typically `src/index.ts` or `src/cli.ts`. In our case, `cli.ts` defines the main loop that asks the user what they want to do.

Open `dapp-cli/src/cli.ts`. You'll see logic that continuously prompts the user:

```typescript
const mainLoop = async (providers: CounterProviders, rli: Interface): Promise<void> => {
  const counterContract = await deployOrJoin(providers, rli);
  if (counterContract === null) {
    return;
  }
  while (true) {
    const choice = await rli.question(MAIN_LOOP_QUESTION);
    switch (choice) {
      case '1':
        await api.increment(counterContract);
        break;
      case '2':
        await api.displayCounterValue(providers, counterContract);
        break;
      case '3':
        logger.info('Exiting...');
        return;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};
```

This loop waits for user input and then calls functions from the `api` module (imported as `api`) to perform the actual work. This clean separation keeps the UI logic (prompts) separate from the business logic (Midnight interactions).

### 2. Provider Configuration (`api.ts`)

Before valid interactions can happen, the application must configure "providers". These are objects that tell Midnight.js how to talk to the outside world.

Open `dapp-cli/src/api.ts` and find `configureProviders`:

```typescript
export const configureProviders = async (wallet: Wallet & Resource, config: Config) => {
  const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
  return {
    privateStateProvider: levelPrivateStateProvider<typeof CounterPrivateStateId>({
      privateStateStoreName: contractConfig.privateStateStoreName,
    }),
    publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
    zkConfigProvider: new NodeZkConfigProvider<'increment'>(contractConfig.zkConfigPath),
    proofProvider: httpClientProofProvider(config.proofServer),
    walletProvider: walletAndMidnightProvider,
    midnightProvider: walletAndMidnightProvider,
  };
};
```

*   **`privateStateProvider`**: Manages the local private storage (where private variables live).
*   **`publicDataProvider`**: Connects to the Indexer to read public ledger state.
*   **`proofProvider`**: Connects to the Proof Server to generate zero-knowledge proofs.
*   **`walletProvider`**: Allows the DApp to request signatures from the user's wallet.

### 3. Calling Contract Methods

When the user selects "Increment", the CLI calls `api.increment`. This function uses the generated TypeScript API to interact with your specific contract.

```typescript
// definition in api.ts
export const increment = async (contract: DeployedCounterContract) => {
  logger.info('Incrementing...');
  const tx = await contract.callTx.increment();
  const { blockHeight } = await tx.public();
  logger.info(`Transaction confirmed in block ${blockHeight}`);
};
```

Notice `contract.callTx.increment()`. The name `increment` comes directly from your Compact contract:
`export circuit increment(): [] { ... }`

The Compact compiler generated the TypeScript definition that ensures this method exists and takes the correct arguments. If you changed the name of the circuit in your `.compact` file, this code would fail to compile!

This type-safety is one of the most powerful features of developing on Midnight.
<AuthGuard>
  <>
    <LoggedInUserInfo />
    <LogoutButton />

    <QuizWithRetry
      questions={[
        {
          question: 'What does the Compact compiler generate to help with frontend integration?',
          options: [
            'GraphQL schemas',
            'REST API routes',
            'TypeScript API definitions for the smart contract',
            'React components for each contract method',
          ],
          answer: 2,
        },
        {
          question: 'What is the main role of Midnight.js in DApp development?',
          options: [
            'Creating and managing testnet wallets',
            'Providing frontend UI templates',
            'Connecting the frontend to the blockchain, wallet, and proof server',
            'Serving as a backend framework for node services',
          ],
          answer: 2,
        },
        {
          question: 'Which of the following is a responsibility of the `configureProviders()` function?',
          options: [
            'Starting the local node and proof server',
            'Setting up access to private state, indexer, node, and proof server',
            'Deploying smart contracts to TestNet-02',
            'Generating Compact smart contract source code',
          ],
          answer: 1,
        },
        {
          question: 'What does the Lace wallet provide when connected to a Midnight DApp?',
          options: [
            'Real-time price data',
            'Automatic code generation for contracts',
            'Transaction signing and account identity',
            'DApp deployment automation',
          ],
          answer: 2,
        },
        {
          question: 'What happens when the user clicks the `incrementBtn` in the example integration code?',
          options: [
            'The DApp disconnects from the wallet',
            'A new smart contract is deployed',
            'The contract method `increment()` is called and the user sees a success message',
            'The app fetches a list of recent transactions',
          ],
          answer: 2,
        }
      ]}
    />
  </>
</AuthGuard>

## Test Your DApp

To test DApps for functionality and security before deploying them on the Midnight network, you should use the dedicated Midnight test environment and available testing libraries.

### Use the Local Midnight Test Environment

Midnight provides a Docker Compose setup that allows you to run a proof server, Midnight node, and Midnight Indexer locally, disconnected from the public Midnight network. This setup simulates a full network environment on your machine, enabling you to test contracts and DApps in isolation before deploying them to the real network.

Start the local test environment using the `standalone.yml` Docker Compose file, such as the one in the [example-counter repository](https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/standalone.yml). This ensures your DApp interacts only with local services during testing.

Navigate to your DApp’s CLI directory and run `yarn standalone`.

When running in standalone mode, the DApp creates a disposable wallet and uses test tokens (tDUST) valid only for offline testing. The DApp uses the wallet SDK to create a wallet from a seed. The wallet address is shown in Bech32m format. This allows you to safely experiment without risking real assets or exposing sensitive data. 

### Automated Testing with Midnight.js Testing Library

The `create-mn-app` template comes with pre-configured tests in `contract/src/test/`. These tests use the `@midnight-ntwrk/midnight-js-testing` library to verify your contract logic locally.

1.  **Run the Tests**:
    From the `contract/` directory, run:

    ```bash
    npm run test
    ```

    *Tip: You can use `npm run test:compile` to compile your contract and run tests in one step.*

2.  **Understand the Tests**:
    Open `contract/src/test/counter.test.ts`. You will see tests that verify the contract's initial state and state transitions:

    ```typescript
    import { CounterSimulator } from "./counter-simulator.js";
    import { NetworkId, setNetworkId } from "@midnight-ntwrk/midnight-js-network-id";
    import { describe, it, expect } from "vitest";

    setNetworkId(NetworkId.Undeployed);

    describe("Counter smart contract", () => {
      it("generates initial ledger state deterministically", () => {
        const simulator0 = new CounterSimulator();
        const simulator1 = new CounterSimulator();
        expect(simulator0.getLedger()).toEqual(simulator1.getLedger());
      });

      it("properly initializes ledger state and private state", () => {
        const simulator = new CounterSimulator();
        const initialLedgerState = simulator.getLedger();
        expect(initialLedgerState.round).toEqual(0n);
      });

      it("increments the counter correctly", () => {
        const simulator = new CounterSimulator();
        const nextLedgerState = simulator.increment();
        expect(nextLedgerState.round).toEqual(1n);
      });
    });
    ```

    If your `counter.compact` implementation is correct, these tests will pass! If they fail, check your contract logic against the solution provided above.

### Functional and Security Testing Steps

* **Unit Test Your Smart Contracts**: Write unit tests for your Compact contracts and run them locally before integration.
* **Simulate DApp Interactions**: Use the CLI or UI to interact with your DApp in the local test environment, verifying all user flows and contract state changes.
* **Check Privacy Guarantees**: Ensure that private data is never sent to the blockchain or indexer—only to the proof server, as enforced by the architecture Midnight architecture.
* **Test Wallet Integration**: Confirm that wallet creation, restoration (using seed), and transaction signing work as expected, especially with the Bech32m address format Midnight test environment.
* **Automate Regression and Security Tests**: Use the testing library’s assertions and environment controls to automate checks for expected contract behavior and to catch regressions.

<AuthGuard>
  <>
    <LoggedInUserInfo />
    <LogoutButton />

    <QuizWithRetry
      questions={[
        {
          question: 'What is the purpose of the `standalone.yml` Docker Compose setup in Midnight?',
          options: [
            'To connect your DApp to the mainnet for live testing',
            'To simulate a full Midnight network environment locally for private testing',
            'To deploy your DApp to the Lace wallet automatically',
            'To compile Compact contracts and generate TypeScript APIs',
          ],
          answer: 1,
        },
        {
          question: 'What kind of wallet is used during standalone testing?',
          options: [
            'A mainnet-synced wallet with real tokens',
            'A browser-based wallet with persistent state',
            'A disposable wallet created from a seed',
            'A cold storage wallet from hardware devices',
          ],
          answer: 2,
        },
        {
          question: 'Which format is used for wallet addresses in the local test environment?',
          options: [
            'Base58Check',
            'Hexadecimal',
            'Ethereum-style (0x)',
            'Bech32m',
          ],
          answer: 3,
        },
        {
          question: 'What is the Midnight.js testing library used for?',
          options: [
            'Compiling and bundling frontend UI files',
            'Querying node status and managing Lace wallet extensions',
            'Running automated tests and managing test environments',
            'Publishing DApps to the Midnight marketplace',
          ],
          answer: 2,
        },
        {
          question: 'What can be controlled via environment variables in test scripts?',
          options: [
            'Smart contract logic and state transitions',
            'Compact version auto-updates',
            'The network type (local, devnet, testnet) and wallet seed',
            'Wallet UI layout and themes',
          ],
          answer: 2,
        },
      ]}
    />
  </>
</AuthGuard>



## Module Summary

In this module, you set up a full development environment for building privacy-preserving DApps on Midnight. You wrote and compiled smart contracts using the Compact DSL, connected your frontend with Midnight.js and TypeScript APIs, and tested your app locally using Docker and the standalone test environment.

You also learned how to securely interact with wallets, generate zero-knowledge proofs, and prepare your DApp for deployment on TestNet-02. With these tools and patterns, you're now ready to build and test real-world applications on the Midnight blockchain.