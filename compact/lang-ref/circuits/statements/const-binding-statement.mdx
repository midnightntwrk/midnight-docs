# `const` binding statement

A new constant can be brought into scope with 

```compact
const x = <expr>;
```

A `const` binding statement can bind multiple constants. The constant bindings are
performed from left-to-right.

```compact
const x = <expr>, y = <expr>;
```

A variable bound by a constant binding cannot be referenced before it is initialized.

```compact
circuit c(): Field {
  // const y = x; // rejected by Compactc
  const x = 1, y = x;
  // const y = x, x = 1; // rejected by Compactc
  return y;
}
```

Each of the constant bindings may optionally be annotated with a type, in which case the type is
checked with the expression.

```compact
const x: T = <expr>;
```

```compact
const x: T = <expr>, y = <expr>;
```

The name of a constant may not be
reused within a block, and constants cannot be reassigned, although they can be
shadowed in a nested block:

```compact
circuit c(): Field {
  const answer = 42;
  // const answer = 12, answer = 1; // rejected by Compactc
  {
    const answer = 12;
    assert answer != 42 "shadowing didn't work!";
  }
  return answer; // returns 42
}
```

Constant initializer expressions are evaluated when the binding statement is executed.

