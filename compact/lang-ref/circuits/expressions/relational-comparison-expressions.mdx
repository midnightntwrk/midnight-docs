
Relational comparison expressions are of the form `e0 op e1` where `e0`
and `e1` are expressions and `op` is one of Compact's relational operators.
The relational operators are **equals** (`==`), **not equals** (`!=`), **less
than** (`<`), **greater than** (`>`), **less than or equals** (`<=`), and
**greater than or equals** (`>=`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>â†’</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>==</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>!=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Equals and not equals require the types of the subexpressions to be in the
subtype relation.  That is, the type of the first subexpression must be a
subtype of the type of the second subexpression, or else the type of the second
subexpression must be a subtype of the type of the first subexpression.

Less than, greater than, less than or equals, and greater than or equals require
the type of both subexpressions to be unsigned integer types (note that `Field`
cannot be compared with these operators).

The type of the result is `Boolean`.

Relational comparison expressions are evaluated by evaluating the subexpressions
in order from left to right.  Then the comparison is performed as described
below.

**Equals**

The comparison that is performed depends on the type of the operands:

- **`Boolean`:** if the operands have type `Boolean`, then the values must be
  the same boolean value.  Both operands will have type `Boolean` due to the static typing rules.
- **`Uint`:** if the operands have unsigned integer types, then the integer
  values must be equal.  Both operands will have unsigned integer types due to
  the static typing rules.
- **`Field`:** if either operand has type `Field`, then the integer values of
  the operands must be equal.  Both operands will have numeric (`Field` or
  unsigned integer) types due to the static typing rules.
- **`Bytes:`** if the operands have bytes types, then the corresponding bytes
  at each index must be equal.  Both operands will have bytes types and their
  lengths will be equal due to the static typing rules.
- **`Tuple:`** if the operands have tuple types, then the corresponding
  element values at each index must be equal according to these rules, based on
  the static element types.  Both operands will have tuple types, they will
  have the the same length, and their element types will be in the subtype
  relation due to the static typing rules.
- **`Opaque:`** if the operands have opaque types, then the runtime values
  must be equal according to JavaScript's strict equality (`===`) operator.
  Both operands will have the same opaque type due to the static typing rules.
- **structure type:** if the operands have structure types, then the 
  corresponding values of each field must be equal according to these rules, 
  based on the field types.  Both operands will have the same structure type due 
  to the static typing rules.
- **enum type:** if the operands have enum types, then they must be the same
  enum value.  Both operands will have the same enum type due to the static
  typing rules.

**Not equals**

The operands are compared according to the rules for equals above, and then the 
boolean result is negated.

**Less than, greater than, less than or equals, and greater than or equals**

The integer values of the operands are compared according to the relational 
operation.  Both operands will have unsigned integer types due to the static 
typing rules.

