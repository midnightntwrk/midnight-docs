# Pure and impure circuits

A Compact circuit is considered *pure* if it computes its outputs from its
inputs without reference to or modification of public state (via the ledger)
or private state (via witnesses).
In practice, the compiler considers a circuit to be impure if
the body of the circuit contains a ledger operation, a call to any impure
circuit, or a call to a witness.

Some external circuits defined in `CompactStandardLibrary` are witnesses;
calls to these make the caller impure.
The remainder are considered pure, so calls to those do not make the caller impure.

A Compact program can declare a circuit to be pure by prefixing the circuit
definition with the `pure` modifier, which must follow the `export` modifier,
if present, e.g.:

```compact
pure circuit c(a: Field): Field {
  ...
}

export pure circuit c(a: Field): Field {
  ...
}
```

The only effect of the `pure` modifier is that the compiler will
flag the declaration as an error if its own analysis determines
that the circuit is actually impure.
The pure modifier allows an application to ensure that the circuit
will be present in the `PureCircuits` type declaration and via the
`pureCircuits` constant in the TypeScript module produced for a
(correct) Compact program by the Compact compiler.

