# Structure types

Structure types are defined by a declaration beginning with the keyword
`struct`.  Here are some examples:

```compact
struct Thing {
  triple: Vector<3, Field>,
  flag: Boolean,
}

struct NumberAnd<T> {
  num: Uint<32>;
  item: T
}
```

A _non-generic structure_ declaration introduces a named structure type, such as
`Thing` in the first example above.  Each non-generic structure declaration
introduces a distinct type, even when the content of the structure is identical
to another.

Structure declarations can also be _generic structure_ declarations, such as
`NumberAnd` in the second example above.  They have a non-empty list of
comma-separated _generic parameter_ names enclosed in angle brackets.  The generic
parameters of a generic structure declaration are in scope in its body.

Generic structure declarations do not introduce a type.  To be used as a type,
they must be _specialized_ by providing a comma-separated list of _generic
arguments_, e.g., `NumberAnd<Uint<8>>`.  Generic arguments must be types,
natural number literals, or a generic size parameter in scope.  Generic
structures must be fully specialized: the number of generic arguments must match
the number of generic parameters.

- Specializations of the same generic structure to the same types are the same
  type.
- Specializations of the same generic structure to different types are different
  types.
- Specializations of different generic structures are always different types,
  even if the specializations are structurally equivalent.
- Specializations of generic structures are always different from non-generic
  structure types, even if the specialization is structurally equivalent to the
  non-generic type.

A structure declaration has a sequence of named fields which must be separated
either by commas or by semicolons.  Comma and semicolon separators cannot be
mixed within a single structure declaration.  A trailing separator is allowed,
but not required.

Each structure field must have a type annotation.

Values of structure types are created with _structure creation_ expressions.
These consist of the structure type (so generic structures must be specialized),
followed by a sequence of field values enclosed in curly braces (`{ }`).  Field
values can be given positionally, in the same order as they are declared in the
`struct` declaration; or they can be named using the field names from the
declaration.  Named field values can appear in any order.  Positional and named
field values can be mixed in the same structure creation expression, but all the
positional ones must come before any of the named ones.  See [Structure
creation](../../circuits/expressions/structure-creation) for the details.

Using the example declarations above, structure values could be created with
`Thing {[0, 1, 2], true}` or `NumberAnd<Uint<8>> { item: 255, num: 0 }`.

Structures may not contain fields containing the same type as the structure,
either directly or indirectly. For example, it is an error to use the following
pair of declarations:

```compact
struct Even {
  predecessor: Odd
}

struct Odd {
  predecessor: Even
}

export circuit doesntWork(s: Even): Odd {
  return s.predecessor;
}
```

