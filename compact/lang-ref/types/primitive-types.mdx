# Primitive types

The following are the primitive types of Compact:

- `Boolean` is the type of *boolean* values.  There are only two values of
  `Boolean` type.  They are the values of the expressions `true` and `false`.

- `Uint<m..n>`, where `m` is the literal `0` or a generic size parameter in
  scope and bound to `0`, and where `n` is a natural number literal or a generic
  size parameter in scope, is the type of *bounded unsigned integer* values
  between `0` and `n`, both inclusive.  (The lower bound is currently required
  to be `0`.)  `Uint` types with different bounds `0..n` are different types,
  although [one may be a subtype of the other](../types/subtyping-and-least-upper-bounds).  In practice, there
  is a (large) maximum unsigned integer value determined by the zero-knowledge
  proving system.  The Compact implementation will signal an error if a `Uint`
  type exceeds this maximum value.

- `Uint<n>`, where `n` is a non-zero natural number literal or a generic size
  parameter in scope and bound to a non-zero natural number, is the type of
  *sized unsigned integer* values with binary representations using up to `n`
  bits.  This is the same type as `Uint<0..m>` where `m` is equal to `(2^n)-1`.
  Sized integer types can be seen as a convenience for programmers.  `Uint<32>`,
  for example, can be more obvious and less error-prone than the equivalent
  `Uint<0..4294967295>`.  Any Compact program that uses sized integer types can
  be rewritten to one that uses only bounded integer types.

- `Field` is the type of elements in the scalar prime field of the
  zero-knowledge proving system.

- `[T, ...]`, where `T, ...` are zero or more comma-separated types is the type
  of *tuple* values with element types `T, ...`.  Note that tuples are
  heterogeneous: the element types can all be distinct.  The *length* of a tuple
  type is the number of element types.  Tuple types with different lengths are
  different types.  Tuple types with the same lengths but where at least one
  element has different types are different types although [one may be a subtype
  of the other](../types/subtyping-and-least-upper-bounds).

- `Vector<n, T>`, where `n` is a natural number literal or else a generic size
  parameter in scope and `T` is a type, is a shorthand notation for the tuple
  type `[T, ...]` with `n` occurrences of the type `T`.  Note that a vector type
  and the corresponding tuple type are two different ways of writing exactly the
  same type.  Unless otherwise specified, type rules for vector types are
  derived from the rules for the corresponding tuple type.

- `Bytes<n>`, where `n` is a natural number literal or else a generic size
  parameter in scope, is the type of _byte array_ values of length `n`.  `Bytes`
  types with different lengths are different types.  `Bytes` types are used in
  the Compact standard library for hashing.  String literals in Compact also
  have a `Bytes` type, where `n` is the number of bytes in the UTF-8 encoding of
  the string.

- `Opaque<s>`, where `s` is a string literal, is the type of _opaque_ values
  with tag `s`.  The syntax of string literals in Compact is the same as in
  TypeScript.  `Opaque` types with different tags are different types.  Opaque
  values can be manipulated in witnesses but they are opaque to circuits.  They
  are represented in circuits as their hash.  The allowed tags are currently
  only `"string"` and `"Uint8Array"`.

