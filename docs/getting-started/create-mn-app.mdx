---
title: Create an MN app
description: Get started using Midnight applications. Set up your wallet, get tokens, and start using privacy-preserving DApps.
sidebar_position: 1
sidebar_label: Create an MN App
tags: [getting-started, setup, user, wallet, ZK]
slug: /getting-started/create-mn-app
toc_max_heading_level: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Step, { StepsProvider } from "@site/src/components/Step/Step";

A Midnight Network (MN) application is a privacy-preserving decentralized application that uses zero-knowledge proofs to maintain data confidentiality. An MN application consists of:

- **Smart contracts** - Written in [Compact](https://docs.midnight.network/develop/reference/compact/) (Midnight's programming language)
- **Frontend application** - Written in TypeScript/JavaScript to provide a user interface

The smart contracts handle the privacy-preserving logic using zero-knowledge proofs. The frontend application allows users to interact with these smart contracts through a web interface.

To build the frontend application, you need TypeScript development tools and Midnight JavaScript libraries. These tools allow your frontend to communicate with the Compact smart contracts.

## Prerequisites

Before you begin, ensure you have:

- Node.js (version 16 or higher) installed
- npm package manager
- Basic familiarity with command-line operations
- Text editor or IDE ([Visual Studio Code](https://code.visualstudio.com) is used in this quickstart)

## Create a new project

### 1. Create a new project folder and initialize a new npm project

The `-y` flag automatically accepts all the default settings, creating a `package.json` file instantly.

```bash
mkdir my-mn-app # Create new project
cd my-mn-app    # Navigate into project
npm init -y     # Initialize new npm project
```

### 2. Create `src` and `contracts` directories

Use the following command to create the required directories:

```bash
mkdir src contracts
```

After running the commands, your project's folder structure should look similar to the following:

```bash
my-mn-app/
├── contracts/
├── src/
└── package.json
```

- `contracts/` is designated for the Compact smart contracts
- `src/` is designated for the web application

## Hello, world!

### 3. Create `hello-world.compact` smart contract

Create the smart contract in the `contracts/` directory and open the contract in Visual Studio Code or your preferred code editor:

```bash
touch contracts/hello-world.compact
```

## The pragma version directive

Every Compact smart contract should start with a **pragma directive**. This line of code declares the compiler version that the contract is compatible with. This ensures the code is not compiled with a newer, potentially incompatible version that could introduce bugs or breaking changes.

### Specify a version

The `pragma` directive specifies the version of the Compact language the contract is written for.

- **Fixed version**: To lock the contract to a single, specific version, use the following syntax:

  ```compact
  pragma language_version = 0.16;
  ```

  This tells the compiler to use exactly version `0.16`.

- **Version range**: It's often more flexible to allow for a range of compatible versions. This approach permits the contract to use minor updates and bug fixes while preventing it from being compiled with a major new release that could contain breaking changes:
  ```compact
  pragma language_version >= 0.16 && <= 0.17;
  ```
  Here, the contract works with versions 0.16 up to 0.17.

The `pragma` directive tells the compiler which version the contract was designed for. Using the wrong version could cause it to malfunction or not run at all. This declaration is a crucial safeguard for predictable contract behavior.

### 4. Add the pragma directive

Add the pragma directive to tell Compact to use versions `0.16` up to `0.17`:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;
```

## The CompactStandardLibrary

An `import` statement for _Compact Standard Library_ is required. This imports Compact's standard library which provides built-in types and functions needed for things like defining byte arrays.

### 5. Add `import CompactStandardLibrary;`

Add the import on the next line of your Compact contract:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;
```

## The ledger declaration

In Compact, the `ledger` section declares the variables that constitute a contract's on-chain state. Think of it as defining the fields in a database that will be permanently stored on the blockchain.

Each state variable is declared with the `ledger` keyword, a unique `identifier` (or name), and a `type`.

**Syntax:**

```
ledger <identifier>: <type>;
export ledger <identifier>: <type>;
```

:::tip

Ledger declarations can be marked as `export` to make them accessible as entry points to the contract from a DApp or other contracts.

:::

### Example: Storing a message

To store messages in the contract's state, we need to choose the right data type. For flexible message storage that can handle any text input, we'll use `Opaque<"string">`, which allows variable-length strings while maintaining Midnight's privacy features.

The `Opaque` type is special in Compact - it allows DApps to pass data without the contract needing to inspect its contents, perfect for user-generated messages.

### 6. Create the `ledger` declaration

This line reserves storage for a variable-length string message:

```compact
export ledger message: Opaque<"string">;
```

Your contract should now look similar to the following:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

export ledger message: Opaque<"string">;
```

## The circuit definition

Circuits are similar to functions in other programming languages, but a circuit is compiled directly into a zero-knowledge circuit. Circuits can take parameters, perform computations, and return values.

**Syntax:**

```
circuit <function>(): [<parameters] {logic}
export circuit <function>(): [<parameters] {logic}
```

:::tip

Circuit definitions can be marked as `export` to make them accessible as entry points to the contract from a DApp or other contracts.

:::

### 7. Export a circuit named `storeMessage` with parameters

Instead of hardcoding a message, let's create a circuit that accepts any custom message as input:

```compact
export circuit storeMessage(customMessage: Opaque<"string">): [] {
    message = disclose(customMessage);
}
```

**Key changes explained:**

- **Parameter**: `customMessage: Opaque<"string">` - accepts any string input
- **Privacy**: `disclose(customMessage)` - explicitly reveals the message to the public ledger
- **Flexibility**: Can now store any message, not just "Hello World"

:::info Why `disclose()`?

Compact enforces privacy by default. All data from witnesses (user input) is considered private unless explicitly disclosed. The `disclose()` function tells Compact we intentionally want this message visible on the public blockchain.

:::

Your complete contract should now look like this:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

export ledger message: Opaque<"string">;

export circuit storeMessage(customMessage: Opaque<"string">): [] {
    message = disclose(customMessage);
}
```

## Advanced Parameter Examples (Optional)

:::warning Optional Section
The following examples are **optional** and for advanced users. For the basic tutorial, skip to the [Compile the smart contract](#compile-the-smart-contract) section below.

**Do not add these to your basic contract** unless you want to explore advanced features.
:::

Now that you understand the basics, let's explore more advanced parameter patterns:

### Message Validation

Add basic validation using a witness function to check message properties:

```compact
witness validateMessage(msg: Opaque<"string">): Bool;

export circuit storeMessage(customMessage: Opaque<"string">): [] {
    // Validate the message using a witness
    assert(validateMessage(customMessage), "Message cannot be empty");
    message = disclose(customMessage);
}
```

:::info Advanced Features Note
These patterns show how flexible Compact circuits can be. For your first deployment, stick with the basic contract above.
:::

## Compile the smart contract

Compact smart contracts need to be compiled because the Compact language is designed to express privacy-preserving logic that is enforced using zero-knowledge proofs (ZKPs). The compilation process serves several purposes:

- _Generation of zero-knowledge circuits_: The Compact compiler transforms the high-level contract logic into zero-knowledge circuits. These circuits are used to generate cryptographic proofs that validate contract interactions without revealing sensitive data. This is fundamental to Midnight's privacy model, where contract logic is enforced and verified cryptographically rather than by code inspection.

- _Creation of TypeScript/JavaScript APIs_: The compiler also outputs strongly typed APIs for use in DApp frontends. This allows developers to interact with the contract from TypeScript or JavaScript code. This ensures type safety and integration between the smart contract and the application.

- _Security and privacy enforcement_: By compiling to circuits and cryptographic artifacts, Compact ensures that privacy rules (such as explicit disclosure requirements) are strictly enforced.

### 8. Navigate to your project's `contracts/` folder and compile `hello-world.compact`

```bash
compact compile hello-world.compact .
```

This generates artifacts in subdirectories, which you can see with a command such as `tree -d`.

```bash
contracts tree -d
.
├── compiler
├── contract
├── keys
└── zkir
```

- The `compiler` directory: This holds the Compact compiler tools and any intermediate files from the compilation process. It is the behind-the-scenes workspace where the compiler turns your high-level Compact code into lower-level representations. In development, you can look here for debugging compilation issues, but usually, you do not touch the files directly; it's for the build pipeline.

- The `contract` directory: This contains your compiled contract artifacts, like JSON files with the contract's logic, metadata, and deployment info. For our example, you can see something such as the compiled circuit definitions. Its purpose is to package everything needed for deploying the contract to the Midnight Testnet or Mainnet. In development, this is where you grab files for integration with your DApp frontend or deployment scripts.

- The `keys` directory: This stores the cryptographic keys, such as proving and verifying keys for zero-knowledge proofs. Since Midnight emphasizes privacy, these keys are important for generating and validating ZK proofs without revealing private data. In development, you can use them for testing proofs locally; for deployment, they are critical for secure on-chain verification.

- The `zkir` directory: This stands for Zero-Knowledge Intermediate Representation. It stores the ZK circuit artifacts, such as the intermediate code that represents your contract's logic in a form ready for proof generation. Its role is to bridge your Compact code to the ZK backend. It is an output that enables privacy features. In development, this helps with optimizing circuits or integrating with proof servers.

These artifacts make up the build output, and are important for everything from local testing to full deployment on Midnight.
