---
title: Create an MN app
description: Get started using Midnight applications. Set up your wallet, get tokens, and start using privacy-preserving DApps.
sidebar_position: 1
sidebar_label: Create an MN App
tags: [getting-started, setup, user, wallet, ZK]
slug: /getting-started/create-mn-app
toc_max_heading_level: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Step, { StepsProvider } from "@site/src/components/Step/Step";

# Creating Your First MN App

A Midnight Network (MN) application is a privacy-preserving decentralized application (dApp) that uses zero-knowledge proofs (ZKPs) to maintain data confidentiality. Its core value proposition is **selective disclosure**, allowing users to prove specific information while keeping all other sensitive data private.


## Prerequisites

Before you start, make sure you have the following installed and ready:

  * **Node.js**: Version 20.x or higher. We recommend installing it via [NVM](https://github.com/nvm-sh/nvm).
    ```bash
    nvm install 20
    ```
  * **Command-Line Familiarity**: Basic knowledge of terminal operations.
  * **Code Editor**: An IDE like [Visual Studio Code](https://code.visualstudio.com).


## Create a New Project

1.  **Initialize your project.**
    Create a new project folder, navigate into it, and initialize an `npm` project. The `-y` flag accepts all default settings.

    ```bash
    mkdir my-mn-app
    cd my-mn-app
    npm init -y
    ```

2.  **Create required directories.**
    Your project will need separate folders for smart contracts and your application source code.

    ```bash
    mkdir src contracts
    ```

    Your project structure should now look like this:

    ```
    my-mn-app/
    ├── contracts/
    ├── src/
    └── package.json
    ```


## Hello, World\!

Now, let's create a "Hello World" smart contract inside the `contracts` directory.

3.  **Create the `hello-world.compact` file.**
    Use the following command to create your first smart contract file.

    ```bash
    touch contracts/hello-world.compact
    ```


## The Pragma Version Directive

Every Compact smart contract must start with a `pragma` directive. This declares the compiler version the contract is compatible with, ensuring predictable behavior and preventing issues with future compiler updates.

You can specify a fixed version (`pragma language_version = 0.16;`) or a compatible range. Using a range is more flexible, as it allows for minor updates and bug fixes.

4.  **Add the pragma directive.**
    Add the following line to the top of `contracts/hello-world.compact` to allow versions from `0.16` up to `0.17`.

    ```compact
    pragma language_version >= 0.16 && <= 0.17;
    ```


## The Compact Standard Library

An `import` statement for the Compact Standard Library is required to access built-in types and functions essential for contract development.

5.  **Add the import statement.**
    Add the import on the next line of your contract.

    ```compact
    pragma language_version >= 0.16 && <= 0.17;

    import CompactStandardLibrary;
    ```


## The Ledger Declaration

The `ledger` section defines a contract's on-chain state variables. Think of it as defining the schema for data stored permanently on the blockchain. Variables can be marked with `export` to make them accessible from a dApp.

**Syntax:**

```compact
ledger <identifier>: <type>;
export ledger <identifier>: <type>;
```

For our "Hello World" contract, we'll use the `Opaque<"string">` type, which allows for storing variable-length strings while preserving privacy.

6.  **Create the `ledger` declaration.**
    This line reserves on-chain storage for a string variable named `message`.

    ```compact
    pragma language_version >= 0.16 && <= 0.17;

    import CompactStandardLibrary;

    export ledger message: Opaque<"string">;
    ```


## The Circuit Definition

Circuits are the functions of a Compact smart contract and are compiled directly into a zero-knowledge circuit. They can take parameters, perform computations, and modify the contract's state. Circuits marked with `export` can be called from external applications.

**Syntax:**

```compact
circuit <function>([parameters]): [return_type] { logic }
export circuit <function>([parameters]): [return_type] { logic }
```

7.  **Define the `storeMessage` circuit.**
    This circuit will accept a custom message as input and store it in the `message` state variable.

    ```compact
    export circuit storeMessage(customMessage: Opaque<"string">): [] {
        message = disclose(customMessage);
    }
    ```

    :::info Why `disclose()`?
    Compact enforces privacy by default. All user input is considered private unless you explicitly make it public. The `disclose()` function tells the compiler that we intentionally want this message to be visible on the public ledger.
    :::

Your complete `hello-world.compact` contract should now look like this:

```compact
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

export ledger message: Opaque<"string">;

export circuit storeMessage(customMessage: Opaque<"string">): [] {
    message = disclose(customMessage);
}
```


## Advanced Parameter Examples (Optional)

:::warning Optional Section
The following examples are for advanced users and should not be added to your contract if you are following the basic tutorial. Skip to the next section to compile your contract.
:::

### Message Validation

You can add validation logic using a witness function to check message properties before storing them.

```compact
witness validateMessage(msg: Opaque<"string">): Bool;

export circuit storeMessage(customMessage: Opaque<"string">): [] {
    // Validate the message using a witness
    assert(validateMessage(customMessage), "Message cannot be empty");
    message = disclose(customMessage);
}
```


## Compile the Smart Contract

Compiling a Compact contract transforms the high-level logic into zero-knowledge circuits, generates cryptographic keys, and creates TypeScript APIs for your dApp frontend. This process is essential for enforcing Midnight's privacy and security guarantees.

8.  **Compile the `hello-world.compact` contract.**
    Run the following command from your project's root directory.

    ```bash
    compact compile contracts/hello-world.compact contracts/managed/hello-world
    ```

    This command generates all the necessary artifacts in the `contracts/managed/hello-world` directory. The generated structure will look like this:

    ```
    contracts/
    └── managed
        └── hello-world
            ├── compiler
            ├── contract
            ├── keys
            └── zkir
    ```

  * `contract/`: Contains your compiled contract artifacts, including JSON files needed for deployment and frontend integration.
  * `keys/`: Stores the cryptographic proving and verifying keys for the zero-knowledge proofs.
  * `zkir/`: The Zero-Knowledge Intermediate Representation of your circuit, bridging your Compact code to the ZK backend.
  * `compiler/`: Holds intermediate files used by the compiler during the build process.