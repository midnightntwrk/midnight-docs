---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
title: Create a MN App
description: Get started using Midnight applications in minutes. Set up your wallet, get tokens, and start using privacy-preserving DApps.
sidebar_position: 1
sidebar_label: Create a MN App
tags: [getting-started, setup, user, wallet, ZK]
slug: /getting-started/create-mn-app
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Step, { StepsProvider } from '@site/src/components/Step/Step';

Midnight's Compact programming language is designed to work within a Typescript development enviroinment in conjuction with associated Midnight JavaScript libraries. Therefore we'll create a new NPM project.

## Create a New Project

1. Create a new project folder and initialize a new NPM project:

The `-y` flag automatically accepts all the default settings, creating a `package.json` file for you instantly.

```bash
mkdir my-mn-app # create new project
cd my-mn-app # navigate into project 
npm init -y # initialize new NPM project
```

2. Now lets create a `src` and `contracts` directories.

```bash
mkdir src contracts
```

### Project Structure ðŸ“‚

After running these commands, your project's folder structure will look like this:

```bash
my-mn-app/
â”œâ”€â”€ contracts/
â”œâ”€â”€ src/
â””â”€â”€ package.json
```

- `contracts/` will be designated for the compact smart contracts.
- `src/` will be designated for the web application.

## Hello, World!

Now, let's create a basic Compact contract that stores the message, "Hello World".

1. Create `hello-world.compact` smart contract in the `contracts/` directory and open the contract in VSCode or your prefered code editor.

```bash
touch contracts/hello-world.compact
```

## The `pragma` Version Directive

Every Compact smart contract should start with a **`pragma` directive**. This line of code declares the compiler version that the contract is compatible with, ensuring the code is not compiled with a newer, potentially incompatible version that could introduce bugs or breaking changes.

### Specifying a Version

The `pragma` directive specifies the version of the Compact language the contract is written for.

**Fixed Version**: To lock the contract to a single, specific version, you use the following syntax:

```compact
pragma language_version = 0.16;
```

This tells the compiler to use **exactly** version `0.16`.

**Version Range**: It's often more flexible to allow for a range of compatible versions. This lets the contract use minor updates and bug fixes while preventing it from being compiled with a major new release that could contain breaking changes.

This can be done using comparison operators like so:

```compact
pragma language_version >= 0.16 && <= 0.17;
```

Here, we're saying it works with versions 0.16 up to 0.17.

Think of the `pragma` directive as telling the compiler which "game console" your "game" (the contract) was designed for. Using the wrong version could cause it to glitch or not run at all. This simple declaration is a crucial safeguard for predictable contract behavior.

1. Now lets write some Compact code! Let's tell Compact to use versions `0.16` up to `0.17`.

Your Compact contract should now look like this:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;
```

## The `CompactStandardLibrary`

Now, we need an `import` statement for *Compact Standard Library*. This pulls Compact's standard library which gives us handy built-in types and functions. We'll need it for things like defining byte arrays later.

1. Add `import CompactStandardLibrary;` on the next line of your Compact contract.

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;
```
Of course. Here is a more concise and comprehensive version of the explanation.

-----

## The `ledger` Declaration

In Compact, the `ledger` section declares the variables that constitute a contract's on-chain state. Think of it as defining the fields in a database that will be permanently stored on the blockchain.

Each state variable is declared with the `ledger` keyword, a unique `identifier` (or name), and a `type`.

**Syntax:**

```
ledger <identifier>: <type>;
export ledger <identifier>: <type>;
```

:::tip

Ledger declarations can be marked as `export` to make them accessible as entry points to the contract from a dApp or other contracts.

:::

### Example: Storing a Message

Let's store a simple message, like the string "Hello World," in our contract's state.

First, we must determine the correct data type. Compact provides several primitive types, including `Bytes<n>`, which represents a fixed-length byte array of size `n`.

Since the string "Hello World" contains 11 characters, we can use the type `Bytes<11>`. We will declare a `ledger` variable named `message` to hold this value.

1. Create the `ledger` declaration:

This line reserves a slot in the contract's storage for an 11-byte value identified as `message`.

```compact
export ledger message: Bytes<11>;
```

Your contract should now look like this:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

export ledger message: Bytes<11>;
```

## The Circuit defintion 

Circuits are similar to functions in other programming languages, but a circuit is compiled directory into a zero-knowledge circuit. Circuits can take parameters, perform computations, and return value.

**Syntax:**

```
circuit <function>(): [<parameters] {logic}
export circuit <function>(): [<parameters] {logic}
```

:::tip

Circuit defintions can be marked as `export` to make them accessible as entry points to the contract from a dApp or other contracts.

:::

1. Export a circuit named `storeMessage`. Inside the circuit assign the `message` a string such as, `"Hello World"`.

```compact
export circuit storeMessage(): [] {
    message = "Hello World";
}
```

Your contract should not look like this:

```compact showLineNumbers
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

export ledger message: Bytes<11>;

export circuit storeMessage(): [] {
    message = "Hello World";
}
```

## Compile the smart contract

Compact smart contracts need to be compiled because the Compact language is designed to express privacy-preserving logic that is enforced using zero-knowledge proofs (ZKPs). The compilation process serves several essential purposes:

- *Generation of Zero-Knowledge Circuits*: The Compact compiler transforms the high-level contract logic into zero-knowledge circuits. These circuits are used to generate cryptographic proofs that validate contract interactions without revealing sensitive data. This is fundamental to Midnightâ€™s privacy model, where contract logic is enforced and verified cryptographically rather than by code inspection.

- *Creation of TypeScript/JavaScript APIs*: The compiler also outputs strongly typed APIs for use in DApp frontends. This allows developers to interact with the contract from TypeScript or JavaScript code, ensuring type safety and seamless integration between the smart contract and the application.

- *Security and Privacy Enforcement*: By compiling to circuits and cryptographic artifacts, Compact ensures that privacy rules (such as explicit disclosure requirements) are strictly enforced. 

1. Navigate to your projects `my-mn-app/contracts/` folder and compile `hello-world.compact`.

```bash
compact compile hello-world.compact .
```

This generates a bunch of artifacts in subdirectories, which you can see with a command like `tree -d`.

```bash
contracts tree -d
.
â”œâ”€â”€ compiler
â”œâ”€â”€ contract
â”œâ”€â”€ keys
â””â”€â”€ zkir
```

- The `compiler` directory: This holds the Compact compiler tools and any intermediate files from the compilation process. It's like the behind-the-scenes workspace where the compiler turns your high-level Compact code into lower-level representations. In development, you might peek here for debugging compilation issues, but usually, you don't touch it directly â€“ it's for the build pipeline.

- The `contract` directory: This contains your compiled contract artifacts, like JSON files with the contract's logic, metadata, and deployment info. For our example, you'd see stuff like the compiled circuit definitions. Its purpose is to package everything needed for deploying the contract to the Midnight testnet or mainnet. In development, this is where you grab files for integration with your DApp frontend or deployment scripts.

- The `keys` directory: Here, you'll find cryptographic keys, such as proving and verifying keys for zero-knowledge proofs. Since Midnight emphasizes privacy, these keys are essential for generating and validating ZK proofs without revealing private data. In development, you use them for testing proofs locally; for deployment, they're critical for secure on-chain verification.

- The `zkir` directory: This stands for Zero-Knowledge Intermediate Representation. It stores the ZK circuit artifacts, like the intermediate code that represents your contract's logic in a form ready for proof generation. Its role is to bridge your Compact code to the ZK backend â€“ think of it as the math-heavy output that enables privacy features. In development, this helps with optimizing circuits or integrating with proof servers.

These artifacts make up the build output, and they're key for everything from local testing to full deployment on Midnight

---

Look at you. ðŸ˜Ž You're already writing and compiling Midnight applications. In the next section we'll dive into deploying our smart contract on chain.
