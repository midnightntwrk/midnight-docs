---
title: Create your first Midnight contract
description: Learn how to create and compile a Hello World smart contract on Midnight's Preprod network.
sidebar_position: 20
sidebar_label: Hello world contract
tags: [compact, smart contract]
toc_max_heading_level: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Step, { StepsProvider } from "@site/src/components/Step/Step";

# Create your first Midnight contract

In this tutorial, you'll create a simple "Hello World" smart contract using Compact, Midnight's smart contract language. 
You'll learn how to write privacy-preserving logic, compile it into zero-knowledge circuits, and prepare it for deployment on the Preprod network.

A Midnight smart contract uses zero-knowledge proofs (ZKPs) to maintain data confidentiality while proving computation correctness. 
The core value proposition is selective disclosure, where users can prove specific information while keeping sensitive data private.

## Overview

By the end of this tutorial, you'll:

- Create a Compact smart contract with state storage
- Compile the contract into zero-knowledge circuits
- Understand the generated artifacts and their purposes
- Prepare your contract for deployment on Preprod

## Prerequisites

Before you begin, ensure you have the following:

- **Compact toolchain**: Follow the [installation guide](./installation) to install the necessary tools.
- **Command-line knowledge**: Basic familiarity with terminal operations.
- **Code editor**: An IDE such as [Visual Studio Code](https://code.visualstudio.com).

<StepsProvider>
<Step>

## Set up your project

First, create a project folder and navigate to it:

```bash
mkdir my-midnight-contract
cd my-midnight-contract
```

Create the required directories:

```bash
mkdir src contracts
```

Your project structure should now look like this:

```
my-midnight-contract/
├── contracts/
├── src/
└── package.json
```

The `contracts` folder will contain your Compact smart contract source files, while `src` will hold deployment scripts and application code.

</Step>
<Step>

## Create the contract file

Now, create the smart contract file where you'll write your Compact code.

Create a new file named `hello-world.compact` in the `contracts` directory:

```bash
touch contracts/hello-world.compact
```

Open this file in your code editor.

</Step>
<Step>

## Add the language version directive

The `pragma language_version` directive specifies which version of Compact your contract uses. This protects your contract from breaking changes in future language versions.

Add this line at the top of `contracts/hello-world.compact`:

```compact
pragma language_version 0.20;
```

This directive tells the compiler that your contract requires Compact version 0.20.

</Step>
<Step>

## Import the standard library

Compact provides a standard library with common types and utilities. You'll need to import it to access built-in functionality.

Add the import statement below the pragma directive:

```compact
pragma language_version 0.20;

import CompactStandardLibrary;
```

The `CompactStandardLibrary` provides essential types like `Opaque`, which are used to store strings while preserving privacy.

</Step>
<Step>

## Define the ledger state

The `ledger` section defines on-chain state variables that persist on the blockchain. This is where you declare what data your contract will store.

Add the ledger declaration:

```compact
pragma language_version 0.20;

import CompactStandardLibrary;

export ledger message: Opaque<"string">;
```

This line creates a state variable named `message` that stores a string value. The `export` keyword makes this variable readable from external applications. The `Opaque<"string">` type allows variable-length strings while maintaining Midnight's privacy guarantees.

</Step>
<Step>

## Create the storeMessage circuit

Circuits are the functions of a Compact smart contract. They define the logic that modifies state or performs computations, and they're compiled into zero-knowledge circuits.

Add the circuit definition:

```compact
pragma language_version 0.20;

import CompactStandardLibrary;

export ledger message: Opaque<"string">;

export circuit storeMessage(newMessage: Opaque<"string">): [] {
  message = disclose(newMessage);
}
```

Let's break down this circuit:

- `export circuit` makes the function callable from external applications.
- `storeMessage` is the circuit name.
- `newMessage: Opaque<"string">` is the input parameter—a private string from the user.
- `: []` indicates the circuit returns no value (void).
- `disclose(newMessage)` explicitly marks the message as public on the ledger.

:::info Why disclose is required
Compact enforces privacy by default. All user input is considered private unless explicitly made public with the `disclose` operator. This ensures developers make conscious decisions about data visibility.
:::

Your complete contract should now look like this:

```compact
pragma language_version 0.20;

import CompactStandardLibrary;

export ledger message: Opaque<"string">;

export circuit storeMessage(newMessage: Opaque<"string">): [] {
  message = disclose(newMessage);
}
```

</Step>
<Step>

## Compile the contract

Compiling transforms your Compact code into zero-knowledge circuits, generates cryptographic keys, and creates TypeScript APIs for integration with frontend applications.

Run the compiler from your project root:

```bash
compact compile contracts/hello-world.compact contracts/managed/hello-world
```

You should see the following output:

```
Compiling 1 circuits:
  circuit "storeMessage" (k=6, rows=26)
```

The compilation process will:
1. Parse and validate your Compact code.
2. Generate zero-knowledge circuits from your logic.
3. Create proving and verifying keys for the circuits.
4. Generate TypeScript bindings for your DApp.

When compilation completes, you'll see a new directory structure:

```
contracts/
├── managed/
|   └── hello-world/
|        ├── compiler/
|        ├── contract/
|        ├── keys/
|        └── zkir/
└── hello-world.compact
```

Here's what each directory contains:

- **contract/**: The compiled contract artifacts, which includes the JavaScript implementation and type definitions.
- **keys/**: Cryptographic proving and verifying keys that enable zero-knowledge proofs.
- **zkir/**: Zero-Knowledge Intermediate Representation—the bridge between Compact and the ZK backend.
- **compiler/**: Intermediate files used during compilation.

</Step>
</StepsProvider>

## Troubleshooting

This section covers common issues you may encounter during compilation and their solutions.

### Compiler not found

If the `compact compile` command isn't recognized:

- Verify the Compact compiler is installed: `compact compile --version`.
- Check that the compiler binary is in your system PATH.
- Refer to the [installation guide](./installation) for setup instructions.

### Compilation errors

If you see syntax or type errors:

- Verify your `pragma language_version` matches your compiler version.
- Check that all required imports are present.
- Ensure the `disclose` operator is used where required.
- Review the error message for specific line numbers and issues.

## Next steps

Now that you've compiled your first Midnight contract, you're ready to deploy it to the Preprod network. 
See the [deploy your contract](./deploy-mn-app) guide for more information.