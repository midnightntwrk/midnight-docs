---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
id: transactions
title: Transactions
sidebar_label: Transactions
description: A reference on transactions in Midnight nodes.
keywords: [node]
---

# Transactions

While the Midnight node supports the standard transaction format provided by the Polkadot SDK, these default-style transactions are not commonly used for on-chain activity in practice. This is because Midnight relies on a proof-based verification model, tightly coupled with the design of the Midnight Ledger.

Most transactions on Midnight are unsigned and adhere to a format defined by the Midnight Ledger itself. Rather than relying on traditional signature-based authorization, these transactions embed a cryptographic proof that attests to the validity of a specific action. This action may be a contract invocation, a contract deployment, or a ZSwap transaction. The presence of this proof allows the network to validate state transitions without needing to expose sensitive data or signatures directly.

When a transaction is submitted, it undergoes several processing stages. First, it is validated within the transaction pool. Validation at this stage checks the well-formedness of the transactionâ€”ensuring it meets the structural and logical requirements defined by the runtime and the ledger specification.

Once included in a block, the embedded proof is fully verified. If valid, the corresponding state transition is executed according to the logic defined in the runtime. The resulting state update is then committed to the on-chain storage layer, completing the transaction lifecycle.
