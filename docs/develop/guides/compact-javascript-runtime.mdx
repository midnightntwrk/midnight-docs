---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# The Compact JavaScript Runtime: run your contracts off-chain

If you’ve written smart contracts before, you’re probably used to languages like Solidity or Rust that compile to on-chain bytecode.

The **Midnight blockchain** takes a different approach. It uses a domain-specific language called **Compact**, designed from the ground up for [zero-knowledge smart contracts](https://docs.midnight.network/develop/reference/compact): programs that can prove their correctness without revealing sensitive data.

When you compile a Compact contract, the compiler doesn’t just generate the zero-knowledge circuits that run on Midnight. It also produces a **JavaScript runtime**, typically found in a file called `index.cjs` in a subfolder next to your `.compact` file.

This runtime lets you execute and test your Compact contract logic directly in JavaScript, using Node.js or any standard testing framework. It’s your bridge between the high-level Compact code and the low-level ZK circuit that runs on-chain.

In this tutorial, we’ll explore the [runtime generated for the bboard contract](https://github.com/midnightntwrk/example-bboard) in depth. You’ll learn:

* How the `index.cjs` file is generated during compilation

* How it’s structured and what each section does

* How the runtime connects JavaScript to Compact’s zero-knowledge circuits

* And how you can use it to write unit tests **or** simulate contract behavior locally

By the end, you’ll understand how Compact’s JavaScript runtime fits into the development workflow — and how it makes testing private smart contracts both accessible and familiar.

## **How the JavaScript Runtime Gets Generated**

When you compile a Compact contract, the compiler produces more than just zero-knowledge circuits — it also emits a matching JavaScript runtime (typically named `index.cjs`). This runtime is essential for simulating, testing, and interacting with your contract logic in a plain JavaScript environment (e.g., Node.js, browser tests). In this section, we’ll walk through *how* and *why* that runtime is generated.

### **The Compilation Pipeline: Compact → Circuits \+ JS Runtime**

Here’s a high-level view of what happens under the hood:

1. **Circuit Generation**  
    The compiler checks your `.compact` files and emits:

   * Zero-knowledge circuits for each contract function or “entry point”.

   * Constraints, witness wiring, etc., to ensure that contract logic is provable.

2. **Runtime File Generation**  
   Concurrently, the compiler generates a **JavaScript runtime file** that mirrors the contract’s structure:

   * It knows which functions exist (their signatures, inputs, outputs).

   * It embeds type descriptors for all Compact types used (integers, booleans, enums, bytes, composite types).

   * It wraps each contract entry point so that you can invoke it in JS, passing native JS values, and get back proofs/state transitions.

   * It includes safety checks to ensure the compiled contract and the runtime remain in sync.

3. **Linking to the Compact Runtime Library**  
   The generated `index.cjs` does *not* reimplement arithmetic, field operations, or other foundational ZK logic; instead, it imports a shared runtime library from `@midnight-ntwrk/compact-runtime`. That library implements:

   * Finite field arithmetic

   * Serialization and deserialization

   * Error types, type checks, alignment rules

   * Circuit-related helper functions  
      The generated file and the runtime library together form a complete environment.

4. **Source Maps & Type Declarations**

   * A **source map** (`index.cjs.map`) is emitted so that debugging or tracing can map back to your original Compact source (line numbers, symbol names).

   * A **TypeScript declaration file** (`index.d.cts`) is generated so that, when you import this runtime in a TypeScript project, you get proper types, autocomplete, and compile-time safety.

Because of these steps, `index.cjs` is not a hand-written artifact but a systematically generated adapter between Compact’s ZK circuits and the JavaScript world.

*Tip:* If you ever change your Compact contract (add or remove functions, change types), a fresh compilation will regenerate `index.cjs` accordingly. Always treat it as generated rather than handwritten, and refrain from changing the code manually.

In the next section, we’ll break down how **`index.cjs`** is structured internally, from boilerplate and imports, through type descriptors and composite types, all the way to the wrapper functions you actually call in your tests.

## **Inside the JavaScript Runtime: Understanding the Structure**

Once you’ve compiled your Compact contract, you’ll find the generated runtime in a file named `index.cjs`.

This file is a self-contained CommonJS module that mirrors your contract’s structure,  from type definitions to callable functions.

Let’s look at how it’s built, piece by piece.

### **1\. Runtime Initialization and Safety Checks**

At the very top, the runtime ensures that the version of `@midnight-ntwrk/compact-runtime` installed in your project matches the version expected by the compiler. It also verifies that the arithmetic field used by the circuits is consistent.

```typescript
'use strict';

const __compactRuntime = require('@midnight-ntwrk/compact-runtime');

const expectedRuntimeVersionString = '0.8.1';

const expectedRuntimeVersion = expectedRuntimeVersionString.split('-')[0].split('.').map(Number);

const actualRuntimeVersion = __compactRuntime.versionString.split('-')[0].split('.').map(Number);

if (expectedRuntimeVersion[0] != actualRuntimeVersion[0] || [...])

  throw new __compactRuntime.CompactError(`Version mismatch...`);

{ 

  const MAX_FIELD = 52435875175126190479447740508185965837690552500527637822603658699938581184512n;

  if (__compactRuntime.MAX_FIELD !== MAX_FIELD)

    throw new __compactRuntime.CompactError(`compiler thinks maximum field value is ${MAX_FIELD}...`);

}
```

This boilerplate ensures that your locally installed runtime matches what the Compact compiler expected when it generated the circuits.

### **2\. Type Definitions and Descriptors**

Next, the file defines **enumerations** and **type descriptors**.

These tell the runtime how to encode and decode the data types used in your contract — like integers, strings, or custom structs.

```typescript 
var State;

(function (State) {

  State[State['VACANT'] = 0] = 'VACANT';

  State[State['OCCUPIED'] = 1] = 'OCCUPIED';

})(State = exports.State || (exports.State = {}));

const _descriptor_1 = new __compactRuntime.CompactTypeUnsignedInteger(18446744073709551615n, 8);

const _descriptor_2 = new __compactRuntime.CompactTypeBytes(32);

const _descriptor_3 = new __compactRuntime.CompactTypeBoolean();

const _descriptor_4 = new __compactRuntime.CompactTypeOpaqueString();
```

Each `_descriptor_*` object defines how values of a given type are represented in zero-knowledge proofs, ensuring consistent serialization between JavaScript and the underlying circuits.

### **3\. Composite Types and Data Structures**

Complex Compact types, like `Option`, `Maybe`, or structured records, are represented as small JavaScript classes that combine primitive descriptors.

```typescript
class _Maybe_0 {

  alignment() {

    return _descriptor_3.alignment().concat(_descriptor_4.alignment());

  }

  fromValue(value_0) {

    return {

      is_some: _descriptor_3.fromValue(value_0),

      value: _descriptor_4.fromValue(value_0)

    };

  }

  toValue(value_0) {

    return _descriptor_3.toValue(value_0.is_some)

      .concat(_descriptor_4.toValue(value_0.value));

  }

}
```

Each of these classes provides methods like `fromValue()` and `toValue()` to convert between **JavaScript objects** and **Compact-compatible encodings**.

### **4\. The Contract Class and Circuit Wrappers**

This is where things get interesting; the generated runtime defines a `Contract` class that mirrors your Compact contract’s **entry points** (such as `post`, `takeDown`, etc.).

These methods don’t execute business logic directly; instead, they prepare inputs, call the pseudo-zero-knowledge circuits, and handle proof data.

```typescript
class Contract {

  constructor(witnesses) {

    this.witnesses = witnesses;

    this.circuits = {

      post: (...args) => {

        const context = args[0];

        const newMessage = args[1];

        const partialProofData = {

          input: { value: _descriptor_4.toValue(newMessage), alignment: _descriptor_4.alignment() },

          output: undefined,

          publicTranscript: [],

          privateTranscriptOutputs: []

        };

        const result = this._post_0(context, partialProofData, newMessage);

        return { result, context, proofData: partialProofData };

      },

      takeDown: (...args) => {

        [...]

      }

    };

  }

}
```

When you call `contract.circuits.post(context, newMessage)` in JavaScript, the runtime automatically:

* Validates input types

* Encodes data for the ZK circuit

* Executes the Compact logic

* Returns structured proof data for verification

### **5\. Exports and Type Bindings**

Finally, the runtime exports everything you’ll need to interact with the contract in your JavaScript code or tests.

`exports.Contract = Contract;`

`exports.State = State;`

The corresponding `index.d.cts` file provides type hints so that when you import this module in a TypeScript project, your IDE understands what functions and structures are available.

Each of these sections works together to make the Compact contract executable outside the blockchain, in a safe and fully verifiable way.

In the next section, we’ll see how you can use this runtime in practice: setting it up in a JavaScript test environment and running contract calls just like you would on-chain.

## **Using the JavaScript Runtime**

Now that you understand how the `index.cjs` file is structured, let’s see how to use it in your own development workflow.

In this section, we’ll walk through how to import the runtime, instantiate the contract, and call its functions from a regular JavaScript or TypeScript environment.

### **1\. Importing the Runtime**

Once you’ve compiled your Compact contract, the compiler will output three key files in the build directory:

- `index.cjs`  
- `index.cjs.map`  
- `index.d.cts`

You can load the runtime just like any other Node.js module:

`const { Contract, State } = require('./index.cjs');`

If you’re using TypeScript, the accompanying declaration file (`index.d.cts`) will automatically provide type hints for your contract and its methods.

### **2\. Instantiating the Contract**

Every Compact contract runtime expects a [**witness object**](https://docs.midnight.network/develop/reference/compact/lang-ref#declaring-witnesses-for-private-state) when it’s created.  
This object typically contains references to cryptographic keys or helper functions that represent a party’s identity in the ZK system.

Here’s a minimal example:

```typescript
const contract = new Contract({  
	localSecretKey: () =>  
		Buffer.from('aabbccddeeff00112233445566778899', 'hex')  
});
```

The runtime checks that this object is correctly formed before allowing any circuit execution — if you forget a required field, it throws a descriptive `CompactError`.

### **3\. Calling Contract Functions**

Each contract entry point (like `post` or `takeDown` in this example) is exposed as a JavaScript function under `contract.circuits`.

These wrappers prepare the inputs, run the JavaScript code emulating the zero-knowledge circuit, and return structured results containing the **output**, **context**, and **proof data**.

```typescript
const context = {  
	originalState: { status: State.VACANT },  
	transactionContext: { timestamp: Date.now() }  
};

const message = "Hello from Compact!";

const { result, proofData, context } =   
	contract.circuits.post(context, message);

// result: Circuit result (e.g., new state)  
// proofData: Data you can use for proof verification  
// context: The new context
```

The `proofData` object contains the same type of witness and transcript information that the blockchain runtime would generate during an actual transaction — meaning you can verify or inspect the same structure locally.

### **4\. Writing Unit Tests**

Because the Compact runtime is just a CommonJS module, you can easily integrate it with **Vitest, Jest**, **Mocha**, or any testing framework you prefer.

```typescript
describe('Bulletin Board Contract', () => {  
	it('should accept a new post', () => {  
		const ctx = { originalState: { status: State.VACANT }, transactionContext: {} };

    const result = contract.circuits.post(ctx, "Test message");

    expect(result.result.status).toBe(State.OCCUPIED);  
	});  
});
```

This makes it easy to test your contract logic off-chain, with full control over inputs and without having to run a Midnight node or a proof server.

The runtime thus serves as your **development playground**: a place to test, simulate, and reason about Compact contract logic before deploying it.

In the next section, we’ll look at **why this design matters**, how the JavaScript runtime bridges human-readable code and zero-knowledge execution, and why it’s key to making privacy-preserving smart contracts developer-friendly.

## **Why This Design Matters**

In the previous section, we saw how you can import the generated runtime, instantiate your contract, and call its functions just like any normal JavaScript class.

But you might be wondering — *why does Compact bother generating a JavaScript runtime at all?*

Why not just compile directly to zero-knowledge circuits and leave it at that?

The answer comes down to **developer experience**, **reproducibility**, and **trust**.

### **1\. A Bridge Between ZK Circuits and Everyday Code**

Zero-knowledge circuits are powerful, but they’re also complex and opaque, not something you can easily debug or test directly.

The JavaScript runtime acts as a human-friendly bridge between the low-level proof system and the high-level contract logic.

When you call:

`const { result, proofData } = contract.circuits.post(context, "Hello world!");`

You’re running exactly the same logic that the ZK circuit will later prove on-chain, but in a form that you can step through, log, and inspect in Node.js.

This means you can **validate the behavior of your contract locally** before you ever need to touch the proof server or submit a transaction to the Midnight network.

### **2\. Type Safety and Consistency Across Environments**

Because the runtime uses Compact’s own type descriptors (`CompactTypeBoolean`, `CompactTypeBytes`, etc.), the data you pass into your JavaScript tests is encoded in the exact same way it will be on-chain.  That consistency eliminates a whole class of subtle bugs, for example, differences in byte order, field alignment, or encoding length.

In practice, it means that if your function works in JavaScript, it will work in Compact:

```typescript
// Your JS test environment

const message = "Hello Midnight!";  
const proof = contract.circuits.post(context, message);

// Your blockchain execution  
// (same inputs, same deterministic behavior)
```

You can test and reason about your contract logic with confidence that the ZK circuit behaves identically.

### **3\. Reproducibility and Proof Transparency**

Each call to a contract method in the runtime returns a structured `proofData` object — a representation of what the zero-knowledge circuit would generate when executed.

That data is crucial for **reproducible testing** and **transparent verification**:

```typescript
{

  input: { value: [...], alignment: [...] },

  output: { value: [...], alignment: [...] },

  publicTranscript: [...],

  privateTranscriptOutputs: [...]

}
```

Having this available directly in JavaScript allows you to **record**, **replay**, and **verify** circuit executions as part of your normal testing flow, without relying on external tools.

### **4\. Developer Productivity Without Compromising Privacy**

The runtime design lets Compact developers use familiar tools,TypeScript, Jest, VSCode, Node.js, while still working with privacy-preserving logic.

Instead of being locked into a specialized proving environment, you can:

* Write integration tests in the same language as your app.

* Simulate user flows off-chain.

* Validate logic changes before recompiling circuits.

It’s the best of both worlds: **developer-friendly ergonomics** with **cryptographic guarantees** under the hood.

Compact’s JavaScript runtime isn’t just a convenience feature; it’s what makes zero-knowledge smart contract development *practical*.

By exposing ZK logic through familiar code, it shortens the gap between concept, implementation, and verification.

In the next and final section, we’ll wrap up with a brief summary of what we’ve learned and how you can start experimenting with Compact contracts yourself.

## **Conclusion**

By now, you’ve seen how Compact smart contracts on the Midnight blockchain are more than just cryptographic programs; they’re part of a full developer workflow.

When you compile a Compact contract, you don’t just get zero-knowledge circuits that the blockchain can prove; you also get a **JavaScript runtime** that mirrors those circuits and lets you test, simulate, and understand your contract logic in a familiar environment.

We started by exploring **how this runtime is generated**, then walked through its **structure**, looking at type descriptors, composite data types, and the `Contract` class that wraps each circuit.

From there, we learned how to **use it in practice**:  importing the runtime, creating a witness object, calling contract methods like `post`, and writing repeatable tests in JavaScript.

Finally, we looked at **why this design matters**: it bridges the gap between developer experience and cryptographic correctness, letting you reason about private, verifiable logic with ordinary code.

The Compact runtime is more than a side product; it’s a key part of what makes building zero-knowledge smart contracts approachable. It gives you confidence that what you test locally will behave the same way once deployed on the Midnight network.

So the next time you compile a Compact contract and see an `index.cjs` file appear, take a moment to open it up, you’ll find a window into how your private, provable logic comes to life.

