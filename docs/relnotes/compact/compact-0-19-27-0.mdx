---
title: Compact compiler 0.27.0 (Compact language 0.19.0)
displayed_sidebar: sidebar
---

## Compact compiler 0.27.0 (Compact language 0.19.0) release notes

Compact compiler version 0.27.0 is being released today.
This version compiles Compact language version 0.19, which is an updated version of the language.

:::important

This is the first version of the compiler which targets the new "Preproduction Testnet" and "Preview Testnet" environments of the Midnight Network.
Contracts compiled with compiler version 0.27.0 or later will not work with the previous environment (known as "testnet" or "testnet-02").
Similarly, contracts compiled with version 0.26 or earlier will not work with the Preproduction or Preview environments.

:::

This release is part of an important milestone for the Midnight Network: the launch of the new Preproduction Testnet and Preview Testnet environments.
Read these release notes carefully to note the breaking changes.

### Summary of changes

The Preproduction and Preview environments are using Midnight ledger version 6 (compared to testnet's ledger version 4).
This version of the ledger has new support for native unshielded tokens.
The Compact standard library has new APIs for unshielded tokens and some breaking renaming changes to existing APIs.

There are new compiler-enforced bounds on various sizes.
This is a breaking change because programs that previously compiled will not compile now.
However, those contracts were unlikely to work anyway.

The generated JavaScript code and the Compact runtime now use ECMAScript modules (ESM) instead Common JS (CJS) modules.
This is a breaking change for your DApps but it will likely simplify them for developers who are working purely with ESM.

This release has several bug fixes and the usual performance improvements.

## Language changes

### New APIs for unshielded tokens

There are new standard library circuits and ledger kernel operations for working with unshielded tokens.

There are new circuits for minting and transferring unshielded tokens:
`mintUnshieldedToken`, `sendUnshielded`, and `receiveUnshielded`.
There are also new circuits for working with unshielded token balances:
`unshieldedBalance`, `unshieldedBalanceLt`, `unshieldedBalanceGt`, `unshieldedBalanceLte`, and `unshieldedBalanceGte`.

The ledger kernel has new operations `mintUnshielded`, `claimUnshieldedCoinSpend`, `incUnshieldedOutputs`, and `incUnshieldedInputs`.

This is not a breaking change, but it did require us to make the breaking change below.

### Name changes to APIs for shielded tokens

To avoid confusion, and to conform to the naming in the on-chain runtime,
the standard library circuits and ledger kernel operations for working with shielded tokens have been renamed.
The structs used in the shielded token APIs have also been renamed.

Those names now contain `Shielded` in them to distinguish them from unshielded counterparts and/or to avoid confusion.

This is a breaking change.
The `compact fixup` tool will fix them.
You can use the Compact devtools to update your contracts.
Make sure you are on devtools version 0.3.0 (or later), which enabled `compact fixup`.
You can do a `compact self update` to update the devtools to the latest version.

To use the fixup tool, first change any `language_version` pragma in your contracts to 0.19 or later and any `compiler_version` pragma to 0.27 or later.
Otherwise, the tool will not change your contract, in order to avoid making incorrect changes.
Then run `compact fixup <file>` on your `.compact` files.
The fixup tool will print the updated contract to standard output.

Note that the fixup tool will also reformat your contract, using the Compact formatter.
It does this because some fixes (such as renaming) will disrupt the existing formatting.
This will happen even if the fixup tool does not make any (other) changes.

### Selective module importing and renaming

You can now selectively import individual elements from Compact modules, and you can individually rename imported elements.
This works like it does in TypeScript and JavaScript's ES modules.

For example:

```compact
import { getMatch, putMatch as originalPutMatch } from Matching;
```

will import `getMatch` as `getMatch` and `putMatch` as `originalPutMatch`, and it will not import any other elements of `Matching`.
This can be used to avoid name clashes (by renaming) including possible future ones if new elements are added to a module (by only importing what you use).

Selective import and renaming works with Compact's existing module prefixes:

```compact
import { getMatch, putMatch as originalPutMatch } from Matching prefix M_;
```

will import `getMatch` as `M_getMatch` and `putMatch` as `M_originalPutMatch`

Note that selective import and renaming works for the standard library too, because `CompactStandardLibrary` is a module.

The original form of import is still supported, though technically this is a breaking change because `from` has been added to the set of reserved words.

### The meaning of `Uint` ranges has changed

`Uint` ranges for bounded unsigned integers, of the form `Uint<0..n>` (**not** sized unsigned integers of the form `Uint<n>`)
are changed to be inclusive on the left (which must be 0) and exclusive on the right (the `n`).
Previously they were inclusive on both the left and the right.

For example, now the type `Uint<0..3>` is interpreted as the set of values {0, 1, 2} where previously it was the set {0, 1, 2, 3}.

These were changed because they were inconsistent with ranges elsewhere in the language, i.e., in `for` loops.
Such inconsistencies can be a source of subtle bugs.

This is a breaking change for bounded unsigned integers.
The more commonly used sized unsigned integers (`Uint<n>`) are unchanged.

The `compact fixup` tool will not update these by default, but you can pass a flag `--update-Uint-ranges` to it and it will attempt to fix them;

- for `Uint<n>` where _n_ is a numeric literal, it will change them to `Uint<m>` where _m_ the numeric literal equal to _n_+1;
- for `Uint<n>` where _n_ is a generic size parameter, it will issue a warning.

To fix code using generic size parameters, you will have to find the _uses_ of the generic (where it's instantiated with a numeric literal) and update them.

### The maximum representable unsigned integer value has changed to be smaller

The on-chain representation of bounded Unsigned integers constrains them to fit within the number of whole bytes in a `Field`, which is currently 31.
Attempts to use unsigned values outside of this range would sometimes have resulted in unexplained proof failures.

The maximum values of `n` in `Uint<n>` and `m` in `Uint<0..m>` have therefore been reduced
to 248 (8 * 31) for `n`
and 452312848583266388373324160190187140051835877600158453279131187530910662656 (2^248) for `m`.

This is a breaking change for the `Uint` type.
Note that the maximum `Field` value is unchanged.

### There are compiler-enforced size bounds

The compiler will now impose a maximum element size bound for tuple, vector (`Vector`), and bytes values (`Bytes`) types.
This maximum element size bound is 2^24 (= 16,777,216).

There is also a maximum depth bound for `MerkleTree` and `HistoricMerkleTree` ledger ADT types.
This maximum bound is depth 32.

These limits were imposed because such programs did not practically work.
For tuples, vectors, and byte values, cryptographic key generation would fail or else the compiler would fail to terminate altogether.
The Merkle tree depth limit is due to a corresponding limit in the Midnight blockchain ledger.

### Generated JavaScript code and the Compact runtime now uses ES modules (ESM)

The compiler-generated JavaScript code and the Compact runtime now uses ESM exclusively.
Previously it used Common JS (CJS) modules.

This was changed because ESM is the official standard JavaScript module system and is becoming more common than CJS as well.
Moreover, mixing CJS modules into projects using ESM can be difficult for developers.

This is a breaking change for your DApps.
You will likely have to change the way that you import the contract code and the Compact runtime if you use it.

## Bug fixes and performance improvements

There are numerous bug fixes, and the size of the circuit representation for making proofs has been reduced in some cases.

Some of these changes are breaking changes:

* Previously not all unreachable statements were reported as such by the compiler.
  Now they are correctly reported, but this means that contracts that previously compile might not compile now.
  The fix is to remove the unreachable code, or even just comment it out.

* The compiler now type checks certain unimported modules that it was not type checking before.
  This can cause programs to fail to compile due to type errors that were not previously caught.
  The fix is to fix the type errors.

* The compiler now rejects multiple-binding `const` binding statements
  and destructuring `const` binding statements
  that occur in single-statement contexts (like a branch of an `if` statement or the body of a `for` loop).
  These could cause confusing downstream compiler errors.
  These are highly unlikely to reflect the programmer's intent because the constants cannot be used anywhere.

* The compiler does not allow casts back and forth from `Bytes<0>` to `Field` or `Uint` values.
  This could sometimes work but could also cause confusing downstream compiler errors.
