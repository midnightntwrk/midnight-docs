---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
id: module-5
title: Developing on Midnight
displayed_sidebar: sidebar
---

import QuizWithRetry from '@site/src/components/QuizWithRetry';
import AuthGuard from '@site/src/components/AuthGuard';
import LoggedInUserInfo from '@site/src/components/LoggedInUserInfo';
import LogoutButton from '@site/src/components/LogoutButton';

# Module 5: Developing on Midnight

## Introduction

Midnight is a next-generation blockchain platform designed to provide data protection, privacy, and security while enabling businesses and developers to build decentralized applications (DApps) without exposing sensitive information. Unlike traditional blockchains that operate with full transparency, Midnight integrates Zero-Knowledge Proofs (ZKPs) to allow selective disclosure, meaning users can prove information validity without revealing underlying data.

<iframe
  width="100%"
  height="400"
  src="https://www.youtube.com/embed/E1UOJD9rohk"
  title="Midnight Developer Academy Module 3"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

This module will guide you through the fundamentals of developing on Midnight, focusing on its architecture, development environment setup, and the Compact framework for smart contract development.

## Learning Objectives

By the end of this module, you will be able to:

* Understand Midnight’s architecture and privacy features.
* Set up a development environment for writing and deploying Midnight applications.
* Learn the basics of Compact, Midnight’s smart contract framework.

## Midnight’s Architecture and Privacy Features

Midnight’s architecture is built to make decentralized application (DApp) development accessible across a wide range of devices, from high-performance servers to everyday mobile phones. As long as the device supports a modern web browser, it can run a Midnight DApp. However, many of Midnight’s privacy-preserving capabilities, such as identity protection and confidential transactions, require advanced cryptographic computations. To balance accessibility with strong security guarantees, Midnight integrates Zero-Knowledge Proofs (ZKPs) and optimizes its architecture by separating lightweight application logic from computationally intensive cryptographic operations.

![Midnight HLA](/img/academy/module-5-1.png)

### The Core of Midnight’s Smart Contract Development

At the heart of this architecture is Compact, Midnight’s domain-specific language for smart contract development. When developers write smart contracts in Compact, the compiler outputs both JavaScript/TypeScript API definitions for the DApp and the cryptographic materials needed to generate ZK proofs. These outputs allow developers to build frontends that interface with Midnight’s privacy infrastructure, ensuring that applications can process transactions and validate user data without exposing sensitive information. Importantly, the Compact compiler runs only on the developer’s system, ensuring that private logic and data remain under local control during development.

### Security Model

Midnight’s security model is built upon zkSNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge), an advanced form of ZKP that enables one party to prove a statement’s validity without revealing any additional information beyond the claim itself. zkSNARKs allow Midnight to facilitate secure transactions, privacy-preserving identity verification, and confidential data exchanges without exposing user identities or transaction details. These cryptographic proofs ensure data integrity and enable businesses to comply with privacy regulations while maintaining full transparency where necessary.

To enforce privacy, Midnight’s proof server is responsible for generating these zero-knowledge proofs. Any sensitive information used in a transaction is sent only to the proof server, never to the blockchain or intermediary services. This architecture ensures that user data remains protected while allowing DApps to prove facts—such as ownership of an asset or eligibility for a service—without disclosing underlying information.

Midnight’s modular design supports multiple deployment models, giving users control over their data exposure. A user could run all necessary components locally, ensuring that nothing leaves their device. Alternatively, they might rely on a cloud-based proof server while keeping private data encrypted. The system also allows for a hybrid approach where private proofs are generated locally, while transaction validation happens in a distributed, decentralized manner. This flexibility ensures that Midnight can cater to various use cases, from fully private environments to enterprise-scale applications requiring selective disclosure.

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>


<QuizWithRetry
  questions={[
    {
      question: 'Which technology allows Midnight to attest to private data without revealing it?',
      options: ['Proof-of-Stake', 'zkSNARKs', 'Sharding', 'Rollups'],
      answer: 1,
    },
    {
      question: 'What is the main function of selective disclosure in Midnight?',
      options: [
        'Encrypting smart contracts',
        'Allowing developers to publish user data on-chain',
        'Enabling users to share only necessary data for specific use cases',
        'Reducing network congestion',
      ],
      answer: 2,
    },
    {
      question: 'Where is private data stored in the Midnight architecture?',
      options: [
        'In the blockchain’s central database',
        'On-chain within encrypted contracts',
        'On the user’s local machine',
        'On a cloud storage server',
      ],
      answer: 2,
    },
  ]}
/>
</AuthGuard>

## Development Environment for Writing and Deploying Midnight Applications

Midnight provides a full suite of tools for building privacy-preserving decentralized applications. This chapter will walk you through the process of preparing your system to interact with the Midnight Testnet—from setting up the core components to running your first transaction. You'll begin by configuring your environment to act as a DApp user, then progressively install the tools necessary to build and deploy your own Midnight smart contracts.

### Interacting with Midnight as a User

Before writing or deploying smart contracts, you’ll begin by becoming a user of the Midnight network. This involves setting up the Lace wallet, installing a local proof server, and acquiring tDUST (test tokens) to interact with the blockchain.

You’ll need:

* A recent version of Docker installed and running.
* The Google Chrome browser (version 119+), as only Chrome is fully supported for wallet extension integration.
* The [Lace Wallet Chrome extension](https://chromewebstore.google.com/detail/lace-beta/hgeekaiplokcnmakghbdfbgnlfheichg)

Once Docker is ready, confirm it’s working by running:

```shell
docker --version
```

You should also verify access to Midnight’s Docker images:

```shell
docker search midnightnetwork
```

### Install the Lace Wallet

1. Download the latest version of the Lace Wallet from [here](https://chromewebstore.google.com/detail/lace-beta/hgeekaiplokcnmakghbdfbgnlfheichg).
2. Pin the extension for easier access.

Start the wallet and create a new testnet wallet. You'll set a password and generate a recovery phrase. You’ll then be prompted to configure wallet settings to connect to:

* The testnet version of the Midnight network.
* A node endpoint.
* The indexer.
* Your local proof server (default: `localhost:6300`).

Once setup is complete, your wallet is ready, but you’ll start with an empty balance.

### Acquire Test Tokens (tDUST)

To make transactions on the testnet, you'll need tDUST. Get some by visiting the Midnight Testnet Faucet, entering your wallet address, and requesting tokens. This will fund your wallet with free, non-transferable testnet tokens, allowing you to pay for smart contract execution.

### Run the Proof Server Locally

Midnight’s privacy guarantees are enforced by a local proof server that handles zero-knowledge proof generation. The proof server never connects to the internet or sends data to third-party services. Its sole role is to receive private transaction data from your wallet and return zkSNARK proofs.

Install and run the proof server via Docker:

```shell
docker pull midnightnetwork/proof-server:latest
docker run -p 6300:6300 midnightnetwork/proof-server -- 'midnight-proof-server --network testnet'
```

You should see logs indicating the server is targeting the Testnet. Keep this running to support proof generation for your wallet transactions.

### Building Midnight Applications

Now that you’re connected to the Midnight Testnet, it’s time to set up your environment to write and deploy real Midnight smart contracts.

First, install Node.js using NVM:

```shell
nvm install 18 --lts
```

You’ll also need:

* The Midnight Compact compiler
* The Midnight TypeScript libraries (available on npm)
* (Optional) The VSCode Compact Extension for syntax support and code validation

### Install the Compact Compiler

Download the `compactc-<platform>.zip` file and unzip it into a dedicated directory. Then, test the installation:

```shell
./compactc --version
```

Mac users may need to allow binaries in **System Preferences → Privacy & Security**.

Set the `COMPACT_HOME` variable in your shell profile for easier tooling integration:

```shell
export COMPACT_HOME='<absolute path to compactc directory>'
```

You may also want to add this path to your system `$PATH`.

### Optional: Install the Compact VSCode Extension

For improved development experience:

1. Download the `.vsix` file from the Midnight releases page.
2. In VSCode, open the Extensions pane → click the ... → “Install from VSIX...”
3. Select the file and restart if prompted.

The extension provides syntax highlighting, inline validation, and contract templates—ideal for both learning and production work.

### You’re Now Ready

At this stage, your environment includes:

* A Lace Wallet with tDUST
* A running local proof server
* Node.js and TypeScript setup
* The Compact compiler and Midnight libraries

You’ve completed your first transaction and are ready to write, compile, and deploy your own Midnight DApps.

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  questions={[
    {
      question: 'Why must the Compact compiler be installed locally?',
      options: [
        'It is only compatible with Mac systems',
        'It contains user interface elements that must run in a browser',
        'It produces sensitive cryptographic material and private API bindings',
        'It requires an internet connection to function',
      ],
      answer: 2,
    },
    {
      question: 'Which browser is fully supported for the Lace wallet extension?',
      options: ['Safari', 'Firefox', 'Chrome', 'Edge'],
      answer: 2,
    },
    {
      question: 'What is the purpose of tDUST on the Midnight testnet?',
      options: [
        'To stake for validator access',
        'To purchase smart contracts',
        'To pay for transactions during testing',
        'To convert into NIGHT tokens',
      ],
      answer: 2,
    },
  ]}
/>

</AuthGuard>

## Learn the basics of Compact, Midnight’s smart contract framework

Compact is a declarative smart contract language made for building privacy-first applications on Midnight.

In most blockchains, everything is public. In others, everything is private. Midnight does something more nuanced — selective disclosure — where private data stays private unless you explicitly choose to reveal it. Compact enforces this by design.

So when you're writing a Compact contract, you're not just writing business logic — you're also defining what’s visible to the world and what’s hidden by default.

### Building Blocks of a Contract

Every Compact contract includes:

* **Ledger state**: Public data stored on the chain
* **Circuits**: Logic that runs on-chain and generates zero-knowledge proofs
* **Witnesses**: Private inputs, typically provided by the DApp or user
* **Types and Structs**: For organizing data
* **Constructor**: Runs when the contract is first created

Here’s a simple Compact contract that stores a public number, restricts who can update or clear it, and only allows one value to be set at a time:

```
import CompactStandardLibrary;

enum State { unset, set }

export ledger authority: Bytes<32>;
export ledger value: Uint<64>;
export ledger state: State;
export ledger round: Counter;

constructor(sk: Bytes<32>, v: Uint<64>) {
  authority = publicKey(round, sk);
  value = v;
  state = State.set;
}
```

This contract sets up a shared public value. Only the user who originally set it can clear it.
One of Compact’s standout features is its strict handling of privacy. Compact enforces a rule: you can’t accidentally reveal private data. If you want to disclose something, you must explicitly declare it using `disclose()`.

For example:

```
witness getSecret(): Bytes<32>;
export ledger publicData: Bytes<32>;

export circuit record(): [] {
  publicData = disclose(getSecret());
}
```

Try skipping the `disclose()` wrapper, and Compact will give you a compiler error. Why? Because it treats all witness data (data coming from the user or DApp) as private by default.

This design protects against unintentional data leaks and makes privacy the standard.

### Working with Witnesses

Witnesses are functions that supply private inputs from outside the contract — usually from the user or DApp.

```shell
witness getSecret(): Bytes<32>;
```

You can use witness data inside circuits, but Compact won’t let you return it, store it, or share it publicly unless you explicitly disclose it.

And even if you try to hide the disclosure (e.g., by changing its format or passing it through other functions), Compact will catch it. It’s like having a privacy-focused compiler buddy watching your back.

### Opaque Types

Compact also supports opaque data types, like `Opaque<'string'>` or `Opaque<'Uint8Array'>`. These are useful for passing data from the DApp into the contract without letting Compact inspect it.

:::note
These values are only opaque within Compact. In your DApp's JavaScript or TypeScript, they’re fully visible. Also, they’re not encrypted on-chain — just not readable from within the Compact program.
:::

**Example**: In the Bulletin Board example, an `Opaque<'string'>` is posted to public state by Compact. Later, another circuit reads it back and sends it to the front-end. But Compact itself can’t "look inside" the string.

### Hashing and Commitment Functions

Compact’s standard library gives you tools to hash and commit to values. These functions help you prove something about data without revealing it.

Examples:

```
persistentCommit(value, random)   // Creates a public commitment
transientCommit(value)            // Creates a temporary commitment
```

These are often used in privacy-preserving protocols like anonymous voting or zero-knowledge authentication.

### Exported Circuits

Circuits are like functions — they define what your contract can do.

Any circuit you export becomes an entry point to your contract. For example:

```
export circuit get(): Uint<64> {
  assert state == State.set "No value yet";
  return value;
}
```

Only circuits marked export are accessible from outside the contract (via the DApp or other contracts). Everything else stays private.

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  questions={[
    {
      question: 'What is the primary purpose of the Compact language?',
      options: [
        'Make contracts faster',
        'Support traditional blockchains',
        'Enforce privacy and selective disclosure',
        'Allow unlimited gas usage',
      ],
      answer: 2,
    },
    {
      question: 'In Compact, what does the disclose() function do?',
      options: [
        'Hides data from the public ledger',
        'Converts private data into public data (with explicit permission)',
        'Encrypts data',
        'Logs private data for debugging',
      ],
      answer: 1,
    },
    {
      question: 'True or False:\nIf you forget to use disclose() when returning witness data, the Compact compiler will show an error.',
      options: ['True', 'False'],
      answer: 0,
    },
  ]}
/>
</AuthGuard>

## Module Summary

Midnight’s architecture enables privacy-preserving DApps on any device by integrating zkSNARKs and separating lightweight app logic from cryptographic processing. Compact, its smart contract language, generates JavaScript/TypeScript APIs and cryptographic proofs, ensuring secure transactions without exposing sensitive data. A dedicated proof server creates zero-knowledge attestations, keeping private data off-chain. Midnight supports multiple deployment models, allowing users to run services locally for full privacy or leverage cloud-based infrastructure while maintaining encrypted data protection.

Midnight provides a development environment for building secure DApps. To get started, install Docker, Google Chrome, and the Midnight Lace Wallet. Then, request test tokens (tDUST) from the faucet and run a local proof server to handle zero-knowledge proofs.

Next, set up your development tools by installing Node.js, the Compact compiler, and the Midnight TypeScript libraries. You can also install the Compact VSCode extension.

After your environment is ready, you can write, compile, and deploy your own Midnight smart contracts.

Compact is Midnight’s smart contract language designed for privacy-first applications. Unlike most blockchains, which are either fully public or private, Midnight enforces selective disclosure, meaning data stays private unless explicitly revealed. Contracts consist of ledger state, circuits, witnesses, types, and a constructor. Compact enforces strict privacy rules, requiring explicit disclosure of private data to prevent accidental leaks. Witnesses supply private inputs, but their data remains hidden unless explicitly disclosed. Opaque types allow DApps to pass data into contracts without Compact inspecting it. Hashing and commitment functions help prove properties about data without revealing it. Circuits define contract logic, and only exported circuits can be accessed externally.

