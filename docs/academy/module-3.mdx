---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
id: module-3
title: Zero-Knowledge Proofs (ZKPs)
displayed_sidebar: sidebar
---

import QuizWithRetry from '@site/src/components/QuizWithRetry';
import AuthGuard from '@site/src/components/AuthGuard';
import LoggedInUserInfo from '@site/src/components/LoggedInUserInfo';
import LogoutButton from '@site/src/components/LogoutButton';

# Module 3: Zero-Knowledge Proofs (ZKPs)

## Introduction

In this module, we explore Zero-Knowledge Proofs (ZKPs) – a powerful cryptographic technique that allows one party to prove a fact to another without revealing the underlying secret. We will cover what ZKPs are, the different types (such as interactive vs. non-interactive proofs, zk-SNARKs, zk-STARKs, etc.), and the basic mechanics behind how they work. We’ll then look at how ZKPs are applied in practice to enhance privacy and scalability in blockchains, with a special focus on Midnight, a blockchain network that leverages ZKPs to protect data confidentiality while supporting regulatory compliance. Finally, we’ll review some concrete examples (case studies) of Midnight’s ZKP usage and the tools it provides to developers, followed by a quiz to test your understanding.

<iframe
  width="100%"
  height="400"
  src="https://www.youtube.com/embed/_zD1u8BamuI"
  title="Midnight Developer Academy Module 3"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

## Learning Objectives

By the end of this module, you will be able to:

* Define what Zero-Knowledge Proofs (ZKPs) are and explain their key properties: completeness, soundness, and zero-knowledge.

* Differentiate between interactive and non-interactive zero-knowledge proofs (ZKPs).

* Compare major zero-knowledge proof systems like zk-SNARKs and zk-STARKs.

* Describe how ZKPs enhance privacy and scalability in blockchain applications.

* Explain how the Midnight network uses ZKPs to preserve data confidentiality and support regulatory compliance.

* Identify key components of Midnight’s architecture that rely on ZKPs, such as Zswap and the Kachina smart contract model.

* Summarize real-world use cases for ZKPs on Midnight, including private voting, decentralized identity, and confidential asset transfers.

* Recognize the developer tools and frameworks provided by Midnight for building zero-knowledge-enabled applications.

* Assess your understanding of ZKPs and Midnight’s implementation through a mix of multiple choice, true/false, and short answer quiz questions.

## Introduction to Zero-Knowledge Proofs (ZKPs)

A zero-knowledge proof is a method by which a prover can convince a verifier that a certain statement is true without revealing any additional information beyond the truth of the statement. In other words, the prover demonstrates knowledge of a secret (or solution to a problem) without sharing the secret itself​. For example, a ZKP could allow you to prove that you know a password without actually disclosing the password, or prove that you are over 18 years old without revealing your exact birthdate​. This seemingly magical property is achieved through clever cryptography, ensuring that nothing is learned by the verifier except that the statement is true.

### Key Properties of ZKPs

All zero-knowledge proof protocols must satisfy three fundamental properties​:

* **Completeness**: If the statement is true and both prover and verifier follow the protocol honestly, then the honest prover can convince the verifier of the statement’s truth​. (In other words, valid proofs will be accepted.)
* **Soundness**: If the statement is false, no cheating prover can convince the verifier that it is true (except with some tiny probability)​. This ensures a fake proof or a lie will not be accepted as true.
* **Zero-Knowledge**: If the statement is true, the verifier learns nothing else beyond that fact​. The proof yields no additional information about the secret or data itself. These properties guarantee that a ZKP is both trustworthy (sound and complete) and privacy-preserving (zero-knowledge). In practice, zero-knowledge proofs involve advanced mathematics to ensure these properties, but the high-level idea is that the prover and verifier run some protocol, where the verifier only accepts if the prover genuinely possesses the secret knowledge.

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'Which of the following is one of the three core properties of a Zero-Knowledge Proof?',
      options: ['Determinism', 'Transparency', 'Completeness', 'Redundancy'],
      answer: 2,
    },
    {
      question: 'True or False: Soundness ensures that no prover can convince a verifier of a false statement.',
      options: ['True', 'False'],
      answer: 0,
    },
  ]}
/>
</AuthGuard>

### Interactive vs. Non-Interactive ZKPs

Early zero-knowledge proofs were formulated as interactive protocols. In an interactive ZKP, the prover and verifier engage in a back-and-forth conversation—often multiple rounds of challenges and responses—to complete the proof. A classic metaphor is the “Ali Baba’s cave”: imagine a cave shaped like a loop with a locked door on one side. The prover claims they know how to open the door. The verifier waits outside and randomly asks the prover to appear from either the left or right path. If the prover can always comply, even across many rounds, it’s convincing they know the secret—without ever revealing the key itself. While this illustrates the essence of zero-knowledge—proving you know something without revealing it—interactive proofs aren’t ideal for decentralized systems like blockchains, which require non-interactive proofs that can be verified by anyone, at any time, without live communication between parties.

Modern applications often use non-interactive ZKPs. A non-interactive ZKP allows the prover to create a single proof artifact that the verifier can check later with no further input from the prover. Non-interactive proofs are typically achieved by using cryptographic tricks (e.g. the Fiat–Shamir heuristic, which replaces a verifier’s challenge with a hash function) so that the interaction is not needed. zk-SNARKs are an example of non-interactive proofs: “SNARK” stands for Succinct Non-interactive Argument of Knowledge. In a zk-SNARK system, the prover can generate a proof without any additional interaction with the verifier​. This is different from interactive ZKPs which “involve multiple rounds of communication”​. Non-interactive proofs are crucial for blockchain uses, as they can be posted on-chain and verified by anyone after the fact, without a live conversation between prover and verifier.

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'What distinguishes a non-interactive ZKP from an interactive one?',
      options: [
        'It requires live video verification',
        'It uses fewer cryptographic algorithms',
        'It can be verified without ongoing communication between prover and verifier',
        'It is only valid on Layer 1 blockchains',
      ],
      answer: 2,
    },
    {
      question: 'True or False: zk-SNARKs are interactive proofs.',
      options: ['True', 'False'],
      answer: 1,
    },
  ]}
/>
</AuthGuard>

### Types of Zero-Knowledge Proof Systems

Modern ZKP systems vary widely in their performance characteristics and trust assumptions. While the boundaries between categories can blur, most systems can be compared based on four key factors:

* **Proof size**: How large is the proof in bytes?

* **Prover time**: How long does it take to generate the proof?

* **Verifier time**: How fast can someone verify the proof?

* **Trusted setup**: Does the system require a special setup ceremony (which must be trusted to remain uncompromised)?

Let’s compare some notable systems:

Groth16 (zk-SNARK): Very small proofs (~200 bytes) and fast verification, but requires a trusted setup that is circuit-specific. That means each new application would need its own setup ceremony. Used in Zcash and some Ethereum zk-rollups.

Plonk (zk-SNARK): A universal SNARK with slightly larger proofs and slower verification than Groth16, but it only needs a one-time trusted setup (reusable across applications). This makes it more practical for ecosystems like Midnight. Halo 2 is an implementation of Plonk with a specific polynomial commitment scheme that supports recursive proofs and avoids trusted setup when used with certain backends.

Bulletproofs: No trusted setup and compact for small statements, but proof size grows with the complexity of the statement (not succinct). Verification is slower, and proof size (~2–20 KB+) becomes impractical for large programs. Used in Monero.

STARKs: Transparent (no trusted setup), post-quantum secure, and scalable for provers. However, the ZK property must be added explicitly, and proofs are large (~100–200 KB). Verification is relatively fast, and they're great for batching computations off-chain (e.g., in StarkNet), but less ideal for use cases like Midnight where proof size and privacy guarantees are critical.

In short, while zk-SNARKs and zk-STARKs are often contrasted, real-world systems blend ideas. Bulletproofs resemble STARKs in scalability and transparency, but aren’t succinct. Plonk sits in the SNARK family but offers better tradeoffs for general-purpose applications.

For a privacy-focused chain like Midnight, a SNARK system with recursive capability and no need for per-circuit setup is ideal—hence the choice of a Plonk-derived system (e.g., Halo 2).

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'Which ZKP system is post-quantum secure and does not require a trusted setup?',
      options: ['zk-SNARKs', 'zk-STARKs', 'Bulletproofs', 'Groth16'],
      answer: 1,
    },
    {
      question: 'What is a downside of zk-STARKs compared to zk-SNARKs?',
      options: [
        'They are incompatible with Ethereum',
        'They produce larger proof sizes',
        'They reveal the secret during verification',
        'They require a trusted setup',
      ],
      answer: 1,
    },
  ]}
/>
</AuthGuard>

### Basic Mechanics of ZKPs

Although the underlying math is complex, it’s useful to have a high-level understanding of how a zero-knowledge proof works:

* There are two parties: the prover (who possesses some secret information or witness) and the verifier (who needs to be convinced of a statement’s truth). The prover wants to convince the verifier without giving away the secret.
* In a typical ZKP workflow, the statement to be proven is formulated in a mathematical way (often as a problem or a circuit). For instance, the statement might be "I know a secret value that hashes to this public hash H," or "I possess credentials that satisfy these conditions."
* Depending on the ZKP protocol, the setup phase plays different roles—but it is always present. In all systems, both the prover and verifier must perform a setup step to generate the proving and verifying keys for a specific computation (or circuit). This setup ensures that both parties are aligned on what is being proved. Before this circuit-specific setup, some systems also require a reference string, which may be:

  - Trusted (e.g., in Groth16 or Plonk), meaning that if the reference string was generated dishonestly, security could be compromised.

  - Transparent (e.g., in Bulletproofs or STARKs), meaning it is derived from public randomness like hash functions and doesn't require trust.

So, the typical flow is:

1. Generate the reference string (trusted or transparent).

2. Run the setup for the specific circuit, producing the proving and verifying keys.

3. Use those keys to generate and verify proofs.

This distinction is critical for security. Users should be aware that they may need to run or validate the setup phase themselves, especially to verify that the dApp they’re interacting with is executing the logic they expect—rather than relying blindly on developer-generated parameters.
* The prover uses the secret witness and the proving key to compute a proof. The prover then performs cryptographic computations (like elliptic curve operations, polynomial commitments, etc.) combining the witness and the public parameters to produce a concise proof​. This proof might be just a few hundred bytes, even if it proves knowledge of a very large or complex secret. (In essence, the prover is attesting that "they know some secret that satisfies all these conditions" without showing the secret.)
* The verifier then uses the corresponding verification key and the reference string to verify the proof. If the proof is valid, the verifier is cryptographically assured that the statement is true (i.e., the prover does know a valid secret witness), with an extremely high degree of certainty. If the proof is invalid, it means either the statement was false or the prover doesn’t actually know a valid secret. All this happens without the verifier learning anything about what the secret is.

The figure below shows a high-level process of a zk-SNARK proof system (non-interactive). First, a setup phase is run for the specific circuit, producing a proving key and a verifying key. In Midnight, the verifier (i.e., the user) is expected to run this setup phase themselves. This is a critical part of the trust model: Midnight does not generate verifying keys on behalf of users. By running the setup themselves, users can ensure that the application logic being proven corresponds exactly to the circuit they expect—preventing malicious or incorrect dApps from hiding behavior behind opaque proofs.

Once setup is complete, the prover (e.g., a dApp or user) uses their secret and the proving key to generate a succinct proof. They send this proof to the verifier (e.g., the network or a user), who checks the proof using the verifying key and the statement’s circuit. The verifier can confirm the prover’s claim without learning the secret itself.

![zk-snarks](https://ucarecdn.com/bacf5357-29d7-490e-8b13-ed13c671efaf/)

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'What is the role of the verifier in a ZKP?',
      options: [
        'To reveal the prover’s secret',
        'To challenge the prover with math problems',
        'To be convinced of the truth of a statement without learning the secret',
        'To generate the proof from scratch',
      ],
      answer: 2,
    },
    {
      question: 'True or False: ZKPs can prove a statement is true even if the prover is lying.',
      options: ['True', 'False'],
      answer: 1,
    },
  ]}
/>
</AuthGuard>

## Applications of ZKPs

Zero-knowledge proofs have become a game-changer in blockchain technology, primarily by addressing two critical challenges: privacy and scalability​. Initially, ZKPs were championed for enhancing privacy, but they are now also proving vital in boosting blockchain scalability and efficiency​. Let’s look at these applications in turn:

* Privacy and Confidentiality: In public blockchains like Bitcoin or Ethereum, all transaction details are typically visible on the ledger. ZKPs allow sensitive data to be hidden while still ensuring transactions are valid. For example, Zcash uses zk-SNARKs to enable shielded transactions where the sender, receiver, and amount can be encrypted, but a proof attached to the transaction convinces the network that the balances check out and no double-spend occurred. This means users gain financial privacy without sacrificing security. Similarly, ZKPs can be used for private transfers of tokens or confidential smart contracts on various platforms. Another example is identity verification: instead of exposing your entire ID document, you could use a ZKP to prove “I am an adult” or “I have a valid driver’s license” without revealing your name, address, or ID number. This has huge implications for compliance with privacy laws (like GDPR) and generally protecting user data in blockchain applications.
* Scalability and Efficiency: Blockchains face scalability limits because every node typically must verify every transaction or every step of a smart contract. Zero-knowledge proofs (ZKPs) offer a way to compress or aggregate computation, offloading work while preserving trust. A prominent application is zk-Rollups on Ethereum: hundreds of transactions are processed off-chain, and a succinct ZKP (usually a SNARK) is generated to prove that all computations were correct. This single proof is posted on-chain, and Ethereum nodes only verify the proof—dramatically reducing on-chain computation. While Ethereum’s base layer currently only supports verifying Groth16 SNARKs, many Layer-2 systems (like StarkNet) perform computation off-chain using hash-based proof systems (i.e., STARKs). These are then wrapped in a Groth16 proof to be verified on Ethereum. This hybrid model combines the scalability and transparency of STARKs with the succinct verification costs of SNARKs. The underlying success of these systems hinges on the “S” in SNARK and STARK—succinctness (short, easily verifiable proofs) and scalability (efficient generation for large computations). This allows hundreds of transactions to be confirmed in the space and cost of one, without needing to trust a third party. Another powerful application is enabling light clients: for example, Mina uses recursive zk-SNARKs to let any participant verify the state of the blockchain using only a few kilobytes of data—rather than downloading the full chain history. Again, succinctness is what makes this possible. In short, ZKPs compress proof-of-computation or proof-of-history, making it feasible to trustlessly verify large computations with minimal bandwidth or effort.

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'How do ZKPs improve scalability on blockchains?',
      options: [
        'By increasing block size',
        'By compressing multiple computations into a single verifiable proof',
        'By allowing transactions without signatures',
        'By duplicating data across nodes',
      ],
      answer: 1,
    },
    {
      question: 'Which of the following is a privacy-enhancing use of ZKPs?',
      options: [
        'Using centralized APIs',
        'Encrypting nodes’ IP addresses',
        'Proving a user is over 18 without showing their date of birth',
        'Storing private keys on-chain',
      ],
      answer: 2,
    },
  ]}
/>
</AuthGuard>

### ZKP in Midnight

Now, let’s focus on how Midnight, the blockchain network in question, employs zero-knowledge proofs. Midnight is a privacy-first network (built as a partnerchain of Cardano) that is “built on a zero-knowledge (ZK) framework” to allow data to be utilized in applications without compromising privacy​. In general, Midnight leverages ZKPs to preserve data confidentiality on-chain while still enabling users to prove necessary facts about that data. A major goal of Midnight is to balance privacy with regulatory compliance – meaning users and organizations can keep data secret on the blockchain, but also selectively disclose or prove compliance when required​. Here are some specifics of how Midnight uses ZKPs for privacy and compliance.

#### Confidential Transactions and Smart Contracts

Midnight uses zero-knowledge proofs to shield sensitive data on its ledger. Transaction details, like sender/receiver identities or asset amounts, can be kept confidential, only visible to authorized parties. Instead of public addresses and plaintext amounts, transactions on Midnight can include ZKPs that validate the transaction’s correctness (balances, signatures, etc.) without revealing the actual values​. This is similar in spirit to Zcash’s shielded transfers but extended to a multi-asset and smart contract setting. Developers can write smart contracts on Midnight that handle private data: the logic can require ZK proofs as inputs. In fact, the smart contract itself is defined by its verification key—and users interacting with dApps are expected to ensure that this key corresponds to the intended contract logic.

#### Selective Disclosure & Compliance Controls

Unlike some “privacy coins” that focus purely on anonymity, Midnight is designed to be compliance-friendly. It supports both shielded (private) and unshielded (public) data within the same framework, giving users and businesses flexibility​. If you want full privacy, you use shielded addresses/transactions. If you need certain data public or need to disclose it to a regulator/auditor, you have that option. Midnight’s model allows granular control over who can see data: for instance, a business could keep its transaction details private from the general public, but later provide viewing keys or proofs to an auditor to demonstrate compliance. The network’s features “let you choose who can access sensitive data” and enable selective data disclosure based on regulatory needs​. In practice, this might involve generating a specialized proof or sharing a decryption key with an authorized party. The key point is that Midnight aims to satisfy regulators (e.g., proving that transactions follow rules, or that users are not sanctioned) without making all data public to everyone. In fact, zero-knowledge proofs can allow organizations to prove compliance (to laws or agreements) without disclosing the underlying confidential data​ – a capability directly aligned with Midnight’s mission.

#### Data Attestations and Identity

Midnight’s ZKP framework can be used for attesting to properties of data. For example, a Midnight application might allow a user to prove they are on a whitelist, or have a certain credential, by supplying a ZKP rather than the credential itself. This enhances privacy for things like KYC/AML checks, age verification, credit score checks, etc. The network makes it possible to integrate such proofs into transactions or smart contract calls. One scenario described is using Midnight for digital identity verification: a decentralized exchange on Midnight could verify a user’s country or accreditation status via proof, “without revealing unnecessary personal details.”​. Such capabilities allow companies to follow regulations (like only allowing licensed investors, or ensuring users aren’t from banned jurisdictions) while respecting user privacy.

#### Scalability and Performance

Midnight’s architecture is designed not only to protect data but also to support high throughput and practical scalability. As discussed earlier, ZKPs reduce on-chain data, enabling efficient transaction batching (as seen in rollups). But Midnight goes further: it integrates the latest advancements in zero-knowledge cryptography to make proof generation and verification fast and scalable. Specifically, Midnight uses the Halo 2 proving system, a recursive SNARK implementation based on Plonk, along with custom elliptic curves tailored for performance. These innovations allow for efficient generation of succinct, recursive proofs without requiring trusted setup, making them ideal for composable, privacy-preserving applications. To address blockchain's traditional concurrency bottleneck, Midnight introduces a smart contract protocol called Kachina. Unlike typical blockchains where smart contract calls are serialized, Kachina supports parallel execution of many transactions or contract actions—while maintaining security and correctness through zero-knowledge proofs. This allows multiple users to interact with private state machines simultaneously, without risking double-spends or data leaks.

#### Smart Contract Integrity in Midnight

In Midnight, smart contracts are represented by zero-knowledge verification keys. That is, the logic of a contract is compiled into a circuit, and the verification key for that circuit becomes the on-chain identity of the contract. When users interact with a dApp, they generate a proof that satisfies the contract’s constraints—and the network checks this proof against the published verification key.

This model flips the trust model: instead of inspecting code, users can cryptographically verify that a dApp does exactly what it claims. To maintain security and avoid deception, it’s critical that users verify that the verification key they’re using matches the one the smart contract expects. This ensures that the logic being proven aligns with the expected behavior, preventing malicious developers from substituting a different circuit with hidden logic.

In summary, ZKPs are at the heart of Midnight’s value proposition: they enable a confidential ledger where users can trust that actions are valid (thanks to proof-based guarantees) without revealing their raw data to anyone. Midnight uses the privacy-preserving power of ZKPs to unlock new possibilities for decentralized apps that handle sensitive information, paving the way for case studies grounded in both trust and confidentiality.

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'What is the main function of selective disclosure in Midnight?',
      options: [
        'Encrypting smart contracts',
        'Allowing developers to publish user data on-chain',
        'Enabling users to share only necessary data for specific use cases',
        'Reducing network congestion',
      ],
      answer: 2,
    },
    {
      question: 'True or False: Midnight allows users to prove compliance with regulations without revealing private data.',
      options: ['True', 'False'],
      answer: 0,
    },
  ]}
/>
</AuthGuard>

### Case Studies in the Context of Midnight

Having covered the concepts, let’s examine how Midnight actually implements and uses zero-knowledge proofs in its architecture and applications. We will look at a couple of technical components of Midnight that rely on ZKPs, as well as example use-cases that have been explored on the network. We’ll also highlight tools and frameworks Midnight provides for developers to build their own zero-knowledge solutions on the platform.

#### ZKP-Powered Protocols in Midnight’s Architecture

Midnight’s core architecture includes specialized protocols that embed zero-knowledge proofs to achieve privacy and security goals. Two key components mentioned in Midnight’s literature are Zswap and Kachina:

* Zswap – Private Asset Swaps: Midnight uses a transaction scheme called Zswap to enable private, atomic swaps of assets on-chain​. This protocol is based on the Zerocash protocol (the same science behind Zcash) and allows multiple assets to be exchanged in one transaction while preserving confidentiality​. For example, imagine Alice wants to swap one token for another with Bob. Instead of them broadcasting a trade that others can front-run or analyze, Zswap lets Alice and Bob jointly produce a zero-knowledge proof that a valid swap occurred (balances updated appropriately) without revealing the exact amounts or even which assets were swapped. Outsiders just see an exchange happened, but not the details. Zswap ensures swaps are atomic (all-or-nothing) and confidential; even if multiple assets are involved, either the entire batch swap executes or none does, and observers can’t glean specifics about the trade. This is especially useful for DeFi use cases where privacy and prevention of front-running (MEV) are important. By merging multiple transactions and hiding asset details, Zswap not only protects users like Alice and Bob, but also improves efficiency, as one proof can validate the correctness of what would otherwise be many separate transactions.
* Kachina – Private Smart Contracts Model: Kachina is the codename of Midnight’s smart contract model, inspired by an IOHK research paper “Kachina: Foundations of Private Smart Contracts.” The Kachina framework provides a unified security model that bridges private state and public state for smart contracts​. In simpler terms, it allows part of a contract’s data to remain secret with the user (off-chain) while still interacting with the public blockchain via proofs. This is a departure from traditional smart contracts (like on Ethereum) where all contract state is public on-chain. With Kachina, a contract execution might go like: the user processes some data locally (e.g., computing an outcome using their private data) and then submits a proof to the blockchain that the computation was done correctly according to the contract’s rules, without revealing the private data. This model enables confidential smart contracts – you can have apps where only authorized parties see the input/output, yet everyone can trust the integrity because of the ZK proofs. It also enhances concurrency: many users can work with a contract simultaneously on their private parts and just post proofs, which mitigates the on-chain contention issue. In Midnight, Kachina-based transaction protocols ensure that even complex operations involving assets or data exchanges maintain security and privacy​. Essentially, Kachina allows Midnight to support versatile data-protecting applications where secrecy and correctness go hand in hand.

These protocols illustrate Midnight’s technical approach: taking cutting-edge ZKP research and embedding it at the protocol level to offer privacy features not possible on ordinary blockchains. Now, let’s see some real-world examples of what developers might build with these capabilities.

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'What does the Zswap protocol in Midnight allow users to do?',
      options: [
        'Run DeFi apps without internet',
        'Stake tokens anonymously',
        'Perform asset swaps privately and atomically',
        'Mint NFTs using zero gas',
      ],
      answer: 2,
    },
    {
      question: 'What is Kachina in the Midnight architecture?',
      options: [
        'A consensus mechanism',
        'A proof-of-work validator',
        'A private smart contract model',
        'A token faucet system',
      ],
      answer: 2,
    },
  ]}
/>
</AuthGuard>

#### Example Use Cases and Applications on Midnight

Midnight is designed as a platform for data-protected decentralized applications (dApps). Think of scenarios where you want to use blockchain benefits (decentralization, integrity, disintermediation) but you need to handle sensitive data responsibly. Here are a few concrete case studies and examples of how ZKPs are applied in Midnight’s context:

* **Secure Voting Systems**: Voting is a classic case where privacy is paramount (votes should be secret) but integrity must be verifiable (only eligible voters vote, and only once). A voting dApp on Midnight can leverage ZKPs to achieve this. For instance, each voter could prove they satisfy eligibility (e.g., citizenship, not voted yet) via a ZKP derived from their digital ID, without revealing their identity​. The actual vote could be cast in encrypted form on Midnight’s ledger. A zero-knowledge tallying algorithm could then prove the final count is correct without revealing individual votes. This way, the process is transparent and verifiable (no cheating in counting, no illegitimate votes) yet preserves voter anonymity. The Midnight network’s support for confidential transactions and selective disclosure is ideal here: you might reveal the final tallies or proofs to an oversight body without revealing any voter’s choices. In fact, Midnight lists secure and confidential voting as a supported use case, where “proven eligibility” can be shown “without revealing identities or preferences.”​ This reduces risks of coercion or retaliation, ensuring privacy in governance.
* **Decentralized Identity and KYC**: Identity verification is often cited as a use case for zero-knowledge proofs, and Midnight is well-suited for this. Imagine an application on Midnight for Know-Your-Customer (KYC) compliance. A user could upload their documents to a trusted verifier off-chain who then issues them a cryptographic credential (like a hash or proof) attesting to certain facts (age, residency, etc.). The user can then interact with services on Midnight by presenting zero-knowledge proofs derived from that credential. For example, a Midnight-based decentralized exchange might require users to prove “I am not a U.S. resident” or “I am over 21” before participating in a certain token sale (to comply with regulations). The user would provide a ZKP to the smart contract, which verifies it and grants access without ever seeing the user’s actual personal data. This keeps the user’s identity private from the world and even from the DEX, while still enforcing the rules. At the Cardano hackathon in 2024, the winning team (Team Crescent) built a prototype of exactly this concept: a dApp to streamline the KYC process using Midnight​. They created a UI for users to complete KYC with a trusted provider, and a view for companies to see that a user is verified (via proofs). By using the Compact smart contract language (Midnight’s programming model) and integrating with the Lace wallet, they showed how a user’s wallet could submit a proof of “KYC-approved” on Midnight, allowing faster customer onboarding​. This showcases Midnight’s potential in sectors like fintech, where compliance is mandatory but customer privacy is a growing concern.
* **Whistleblowing and Sensitive Data Sharing**: Another idea explored in the hackathon was a dApp for protecting whistleblowers​. Consider a platform where employees or citizens can report misconduct or submit complaints anonymously. Using ZKPs, such a system could allow a whistleblower to prove they are an authenticated employee (so the report is credible) without revealing their identity. Midnight’s infrastructure could ensure the content of the complaint is encrypted on-chain. Only authorized investigators could decrypt the details, but the system could publish a proof that “a valid report was submitted at a certain time” to create an immutable audit trail. This kind of application requires the blend of privacy and selective transparency that Midnight provides. Similarly, the hackathon saw ideas like secure résumé sharing (salespeople proving their employment history to prospective employers without exposing all past data) and a private data marketplace (a Telegram bot to let users sell their chat data to AI companies, presumably by proving the data’s validity without immediately exposing it)​. These creative use cases all hinge on the ability to prove statements about data (employment records, data authenticity) without open access to the data until a purchase or permission is granted. Midnight’s ZKPs make such workflows feasible in a decentralized context.
* **Asset Tokenization with Privacy**: Midnight can facilitate tokenization of real-world assets with privacy. Suppose you tokenize a piece of real estate – the ownership records and transactions could be sensitive. On Midnight, you could mint a token representing the property and transfer it via confidential transactions. Ownership changes would be recorded, but details (who the owner is, how much they paid) can be shielded. Only authorized parties (like a registry authority or the involved parties) can obtain details when needed (for legal processes), possibly by sharing a view key or creating a disclosure proof. Meanwhile, to everyone else, the property token’s transfer history is opaque but verifiably consistent. This concept was mentioned as a use case: “storing ownership details on-chain without exposing personal data”​, which is crucial for assets like real estate or high-value collectibles that might need privacy.

In essence, Midnight opens the door to “any use case requiring data and/or metadata protection.”​ If an application needs to use personal or sensitive data but on a blockchain, Midnight’s ZKP-based approach can provide the needed confidentiality. The above examples (voting, KYC, whistleblowing, private trades, asset tokenization) are just a sample — developers can undoubtedly conceive many more (private medical records systems, confidential supply chain verification, etc.). The hackathon projects and Midnight’s own documentation highlight that combination of privacy + integrity can unlock innovative solutions in regulated industries, where both data protection and compliance are mandatory​.

### Quiz

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  module="Module 3"
  questions={[
    {
      question: 'Which use case would benefit from ZKPs in a whistleblower app?',
      options: [
        'Hiding gas fees',
        'Proving employee status without revealing identity',
        'Reducing token inflation',
        'Publicly listing all reports',
      ],
      answer: 1,
    },
    {
      question: 'True or False: Midnight can allow tokenized asset transfers without revealing the owner’s identity.',
      options: ['True', 'False'],
      answer: 0,
    },
  ]}
/>
</AuthGuard>
