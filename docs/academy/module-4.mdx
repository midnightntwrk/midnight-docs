---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
id: module-4
title: Kachina Protocol
displayed_sidebar: sidebar
---

import QuizWithRetry from '@site/src/components/QuizWithRetry';
import AuthGuard from '@site/src/components/AuthGuard';
import LoggedInUserInfo from '@site/src/components/LoggedInUserInfo';
import LogoutButton from '@site/src/components/LogoutButton';

# Module 4: Kachina Protocol

## Introduction

Kachina Protocol is a research-driven framework for building private (data-protecting) smart contracts. It addresses the challenge of keeping sensitive data confidential on a public blockchain. This protocol is especially relevant to Midnight, Cardano’s privacy-focused network, which leverages Kachina to enable secure and decentralized smart contracts with strong privacy guarantees​. 

<iframe
  width="100%"
  height="400"
  src="https://www.youtube.com/embed/UrysyDPzay4"
  title="Midnight Developer Academy Module 3"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

In this module, we will explore what the Kachina Protocol is, why it’s important for private smart contracts, how it works (in a simplified way), and how it bridges formal security theory with the practical development of privacy-preserving applications.

## Learning Objectives

By the end of this module, you will be able to:

* Define private smart contracts and explain why privacy is important in blockchain applications.

* Describe the Kachina Protocol and its role as a unified framework for deploying privacy-preserving smart contracts.

* Understand the Universal Composition (UC) model and why it provides strong real-world security guarantees.

* Explain how Kachina uses the UC model to formalize an “ideal” private contract and ensure the real implementation meets that ideal.

* Identify practical use cases for Kachina (e.g. private payments, DAO governance, voting) and outline how to design an application using Kachina’s principles.

## Foundations of Private Smart Contracts

In traditional smart contracts (like those on Ethereum), all data and transactions are transparent to the public. While valuable, this transparency poses a problem: smart contracts often handle sensitive data (like financial details or personal information) that anyone can see on the blockchain​. Private smart contracts aim to solve this by keeping certain data hidden (encrypted or off-chain) while still enforcing contract rules. In other words, they let you have blockchain-based applications with confidentiality – only authorized parties learn the private details, but everyone can still verify that the contract is executed correctly.

Without privacy, many use cases are impractical on public ledgers. Imagine a company wanting to use a blockchain for supply chain or a person wanting to do a salary payment via a smart contract – they wouldn’t want all details public. Privacy-preserving contracts enable things like confidential financial transactions, private votes, or handling personal data in a decentralized way. Maintaining confidentiality on a blockchain is difficult (“How can data confidentiality be maintained when information is, by design, visible to everyone?”​), but it’s essential for the broader adoption of smart contracts in areas that require secrecy or compliance. Early solutions for contract privacy existed (using techniques like secure computation or zero-knowledge proofs) but were often ad-hoc, each tailored to a specific application and sometimes requiring trusted components (for example, some systems relied on special hardware or a fixed set of trusted parties)​. This fragmentation meant there was no general, uniform way to create private contracts comparable to how Ethereum provided a uniform platform for public contracts​.

### Kachina’s unified framework

Kachina was introduced to provide “one unified method” to construct a wide range of privacy-preserving smart contracts​. Instead of inventing a new protocol for each private application, developers can use the Kachina framework as a common foundation. Kachina identifies a large class of computations that can be expressed as smart contracts with privacy guarantees without additional trust assumptions (no need for trusted third parties or special hardware)​. This means Kachina contracts rely purely on cryptography for security. In fact, Kachina’s protocol uses only zero-knowledge succinct non-interactive arguments of knowledge (ZK-SNARKs, a type of zero-knowledge proof) to enforce privacy​. Zero-knowledge proofs allow someone to prove a statement (like “this transaction follows the contract rules”) without revealing the underlying private data. By leveraging these proofs, Kachina contracts keep data secret but verifiably correct.

A major strength of Kachina is how it bridges rigorous formal security theory with practical deployment. It introduces a unified security model (based on the Universal Composition framework) and, at the same time, provides a blueprint for the actual implementation of private contracts​. In simpler terms, Kachina comes with mathematical proofs that its contracts are as secure as an ideal private system, and it shows how to build those contracts in reality using blockchain transactions and cryptographic proofs. This bridge means developers can have confidence in the privacy guarantees (thanks to formal proofs) while being able to implement contracts on a real network (thanks to Kachina’s concrete design). The Midnight network is an example of practice built on Kachina’s theory: it implements Kachina’s principles to offer data-protecting smart contracts that are both practical and backed by formal guarantees​.

Some key benefits of the Kachina approach include:

* **Generality**: It supports a broad range of private smart contracts (payments, voting, asset management, etc.), not just one specific use-case​. This general-purpose nature is similar to how Ethereum is general (but here with privacy in mind).

* **No Trusted Parties**: Kachina does not require any centralized or trusted components. All parties can be fully trustless, preserving decentralization.

* **Composability**: Contracts built under Kachina’s model have strong security that holds even when run alongside other contracts. This uniform model makes it easier to combine or extend systems without breaking privacy guarantees.

* **Concurrency**: The framework is designed to allow multiple users to interact with the contract simultaneously without leaking information. (Earlier privacy protocols often had sequential or rigid interaction patterns; Kachina, by design, facilitates concurrent interactions without sacrificing security).

* **Efficiency via Cryptography**: By using succinct zero-knowledge proofs (like ZK-SNARKs), Kachina contracts can be verified quickly and keep on-chain data small​. In short, heavy computation can be done off-chain in proofs, and on-chain we store minimal proof data, making the system scalable for real-world use.

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  questions={[
    {
      question: "Why are private smart contracts needed on public blockchains?",
      options: [
        "Because public blockchains are fully transparent, and many applications involve sensitive data that users don’t want to expose to everyone.",
        "Because they execute faster than regular smart contracts on a blockchain.",
        "Because blockchains cannot function without privacy features.",
        "Because they allow anyone to change contract data without others noticing."
      ],
      answer: 0
    },
    {
      question: "What is the Kachina Protocol?",
      options: [
        "A unified framework for deploying privacy-preserving smart contracts, providing formal security guarantees and general-purpose privacy features.",
        "A new consensus algorithm for faster block production in Midnight.",
        "A centralized service that hides blockchain data by removing it from the ledger.",
        "An off-chain storage system for smart contracts."
      ],
      answer: 0
    },
    {
      question: "Which of the following best describes a “private smart contract”?",
      options: [
        "A smart contract that keeps certain data and transaction details hidden (private), while still allowing the network to verify that the contract’s rules are followed.",
        "A contract that is not stored on any blockchain, only on the users’ local machines.",
        "A standard public smart contract that only uses encrypted programming language.",
        "A contract that has no code and only manual enforcement to keep it private."
      ],
      answer: 0
    },
    {
      question: "How does Kachina “bridge theory and practice” in the context of private contracts?",
      options: [
        "By providing a formal security model (with proven privacy guarantees) and also a practical method (using blockchain transactions and zero-knowledge proofs) to implement those guarantees.",
        "By prioritizing practical deployment and ignoring formal security proofs.",
        "By creating a new programming language that automatically writes secure code without any theoretical basis.",
        "By requiring developers to manually prove their contracts secure without any framework."
      ],
      answer: 0
    }
  ]}
/>
</AuthGuard>

## Security Model

To truly understand Kachina, we need to grasp its security foundation: the Universal Composition (UC) model. This is a formal framework from cryptography for describing and proving security of protocols. While the term sounds complex, the core idea is straightforward - **Universal Composability**.

If a protocol is secure in the UC model, it remains secure even if it’s composed with other protocols or run in a complex environment. In real-world terms, this means even if multiple smart contracts (or multiple instances of a contract) are running at the same time, and adversaries are trying to interfere, a UC-secure protocol won’t lose its security properties. This is important because blockchain systems are highly concurrent and adversarial – many things happen in parallel on-chain. The UC model gives a strong guarantee suitable for such conditions.

Think of the UC model as a “plug-and-play” security guarantee. If each component (contract) is UC-secure, you can plug them together and the whole system stays secure. This is unlike weaker models where a protocol might be secure alone but could break when running at the same time as another. For developers, UC security is comforting: it’s like knowing your module has been tested under all combinations and still holds up.

### Ideal functionality vs. real protocol

In the UC framework, we often describe an ideal world and a real world. The ideal world contains a hypothetical perfectly secure service (called an ideal functionality) that does the job of the smart contract with complete privacy. For example, imagine an ideal trusted referee who takes in secret inputs from parties and outputs the correct results – this ideal referee never leaks anything beyond the intended output. The real world is our actual implementation (a blockchain protocol with users, cryptography, etc.) which has no trusted referee, only code and math. A protocol is UC-secure if, for every attack on the real world, there’s a way to “simulate” it in the ideal world such that the outcome looks the same to all parties. In essence, no attacker can tell the difference between interacting with the real protocol and the ideal perfectly-secure service. Therefore, if the ideal functionality doesn’t leak any sensitive info, the real protocol won’t either (otherwise the attacker would notice a difference). Kachina’s security is proven in this way – it shows that whatever can happen in a Kachina-based contract execution is as if a trusted private service handled the data correctly.

### Why is UC important for Kachina

Kachina’s goal is to allow arbitrary smart contracts with privacy, which means these contracts will inevitably interact with other contracts and users on a network. By using the UC model, the designers of Kachina ensure that its privacy guarantees hold in the wild, not just in a lab setting. The privacy and integrity of a Kachina contract are guaranteed even if:

* The contract runs concurrently with other contracts or multiple instances of itself.

* Malicious actors try to interleave transactions or run unforeseen interactions.

The UC model essentially future-proofs the security: developers can build on Kachina without worrying that some new complex use of their contract will open a hole in its security. In the Kachina research paper, the authors explicitly prove that a Kachina-based private payment contract is provably secure in the UC setting​. This means they modeled an ideal private payment ledger (where a trusted bank keeps everyone’s balances secret, for example) and showed the Kachina protocol realizes that ideal. As a result, the real protocol leaks no more information than the ideal would. Such strong guarantees are rarely achieved in typical smart contract development.

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  questions={[
    {
      question: "What does the Universal Composition (UC) security model ensure for protocols like Kachina?",
      options: [
        "That the protocol remains secure even when run alongside other protocols or multiple instances; its security properties hold in a broad, real-world scenario.",
        "That the protocol can only run one user at a time to stay secure.",
        "That the protocol’s code is automatically generated from a specification.",
        "That the protocol uses a universal programming language for all blockchains."
      ],
      answer: 0
    },
    {
      question: "In simple terms, what is an “ideal functionality” in the context of Kachina’s security model?",
      options: [
        "An imaginary perfectly secure version of the contract (often thought of as a trusted third-party service) that privately does what the contract should do, used as a benchmark to define security.",
        "A special mode that the blockchain runs in to hide all data (the “ideal mode”).",
        "The user interface of the smart contract application.",
        "The code library in Kachina that provides cryptographic functions."
      ],
      answer: 0
    },
    {
      question: "How does Kachina use the UC model to guarantee privacy?",
      options: [
        "It defines an ideal private contract (where a trusted party would keep secrets) and then proves that the actual blockchain protocol with Kachina is indistinguishable from that ideal. This means the real contract leaks no more information than the ideal scenario would.",
        "It requires all users to sign a legal contract (UC) promising not to leak data.",
        "It runs the contract twice (one real, one ideal) to check for differences at runtime.",
        "It only allows one contract on the network at a time to avoid interference."
      ],
      answer: 0
    }
  ]}
/>
</AuthGuard>


## Practical Implementation

Now that we’ve covered the what and why, let’s look at how Kachina works in practice (conceptually). The Kachina protocol introduces a specific architecture for smart contracts to achieve privacy:

* A Kachina-based smart contract splits its state into two parts: a public state and a private state​
docs.midnight.network. The public state resides on-chain (visible to everyone on the blockchain), while each participant in the contract maintains their own private state off-chain (visible only to themselves). For example, the public state might include encrypted outputs, commitment identifiers, or public keys, whereas the private state could be a user’s secret data like their balance, private inputs, or keys.

* The contract is designed such that any update (transaction) will update both the public and private state together in a coordinated way​. When a user wants to perform an action on the contract, they do two things: (1) update their own private state according to the action (for instance, subtract the amount they want to spend from their secret balance), and (2) prepare a zero-knowledge proof that this private update is valid with respect to the contract’s rules.

* The zero-knowledge proof (ZK-SNARK) is the magic that ties it all together. The user generates a proof asserting “I have a valid private state and input that allow me to make this change to the public state according to the contract’s rules, but I won’t reveal those secrets.” This proof is then attached to a transaction that also includes any necessary public data (like a new encrypted value or a reference to something in public state). Crucially, the proof does not reveal the private state or input – it’s purely a mathematical witness of legitimacy.

* When the transaction is submitted, the network (miners/validators) will verify the zero-knowledge proof against the current public state. If the proof checks out, it means the proposed public state update is consistent with some valid private state held by the user, even though the network doesn’t know the details. The network then applies the public state changes (for example, updating a ledger of commitments or adding a record of an action) without ever learning the private details that justified the change.

* After the transaction is confirmed on-chain, the user (and possibly other parties involved) updates their own off-chain private state accordingly, knowing that the contract’s rules were enforced. Any authorized outputs (like a receipt or an encrypted message) can be read by those who are allowed, but outsiders learn nothing beyond what’s in the public state and the fact that a valid proof was provided.

This architecture effectively creates a trusted execution environment in code: the combination of the blockchain + zero-knowledge proofs plays the role of that “ideal trusted referee” we imagined. It ensures everyone plays by the rules but without exposing private data. Kachina’s core idea of separating on-chain and off-chain state, paired with proofs, is what makes this possible.

### Concurrency and scalability

One impressive aspect of Kachina’s implementation is that it supports concurrency. Multiple users can interact with the contract (even at the same time) and create transactions that will all be verified independently with their proofs. Thanks to the UC-based design, these concurrent interactions remain secure. The Kachina framework introduces the concept of state oracle transcripts to handle ordering and dependencies of state updates in a way that minimizes information leakage​. In simple terms, it has a method to sequence transactions and resolve conflicts so that even when users’ actions overlap, no private data is accidentally revealed and the contract’s state remains consistent. This means higher throughput and a smoother user experience, as users don’t have to wait in line to use the contract one at a time. Concurrency in a privacy protocol is non-trivial, and Kachina’s design is a big step in making private smart contracts practical at scale.

<AuthGuard>
<>
    <LoggedInUserInfo />
    <LogoutButton />
  </>

<QuizWithRetry
  questions={[
    {
      question: "Kachina’s core idea is to split a smart contract’s state into two parts. What are they?",
      options: [
        "A public state stored on-chain, and a private state kept off-chain by each participant.",
        "An encrypted state and a decrypted state, both on-chain.",
        "A developer state and a user state, managed on a central server.",
        "A permanent state and a temporary state, similar to memory and disk."
      ],
      answer: 0
    },
    {
      question: "What is the role of zero-knowledge proofs in Kachina-based smart contracts?",
      options: [
        "They allow users to prove that a proposed public state update is valid (follows the contract rules given their secret inputs) without revealing those private inputs or state.",
        "They encrypt all of the contract’s code so that no one can read it.",
        "They automatically generate new smart contract logic when needed.",
        "They let users share their private data with the blockchain so it can be verified publicly."
      ],
      answer: 0
    },
    {
      question: "Which of these applications could be built using the Kachina privacy framework?",
      options: [
        "A decentralized voting system where each person’s vote is secret but the final tally is verifiable by all.",
        "A public photo-sharing app where all images are visible to everyone by design.",
        "An open marketplace smart contract that publishes every bid and transaction in plaintext.",
        "A blockchain explorer tool that reads public data from the ledger."
      ],
      answer: 0
    },
    {
      question: "How does Kachina handle multiple users interacting with a contract at the same time (concurrency)?",
      options: [
        "It’s designed to support concurrent interactions by verifying each user’s action with a proof and using an ordering mechanism (like transcripts) to prevent conflicts, all while preserving privacy.",
        "It doesn’t allow concurrency – users must take turns one-by-one to maintain privacy.",
        "It uses a centralized queue server to line up transactions (breaking decentralization for the sake of privacy).",
        "Concurrency is not possible in Kachina; any simultaneous actions would reveal private data."
      ],
      answer: 0
    }
  ]}
/>
</AuthGuard>


